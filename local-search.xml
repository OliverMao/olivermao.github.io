<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/2022/12/07/C-STL/"/>
    <url>/2022/12/07/C-STL/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-STL概述"><a href="#第一章-STL概述" class="headerlink" title="第一章 STL概述"></a>第一章 STL概述</h1><h2 id="1-1-STL是什么"><a href="#1-1-STL是什么" class="headerlink" title="1.1 STL是什么"></a>1.1 STL是什么</h2><p><strong>STL</strong>(Standard Template Library)，标准模板库</p><p>STL主要包含容器、算法和迭代器三大部分。</p><ol><li>容器<br>包含了绝大多数数据结构，如数组、链表、队列、堆、栈、树等。</li><li>算法<br>包含了诸如增删改查排序等系统函数</li><li>迭代器<br>类似于指针，通过它的有序移动把容器中的元素与算法关联起来，是实现所有STL功能的基础所在。</li></ol><p>常用STL包含文件</p><table><thead><tr><th>索引</th><th>功能</th><th>包含文件</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>迭代器</td><td>#include<iterator></td><td></td></tr><tr><td>2</td><td>输入输出流</td><td>#include<iostream></td><td>标准输入输出流</td></tr><tr><td></td><td></td><td>#include<fstream></td><td>文件输入输出流</td></tr><tr><td></td><td></td><td>#include<sstream></td><td>字符串输入输出流</td></tr><tr><td>3</td><td>字符串</td><td>#include<string></td><td></td></tr><tr><td>4</td><td>函数对象</td><td>#include<functional></td><td></td></tr><tr><td>5</td><td>通用容器</td><td>#include<vector></td><td>向量容器</td></tr><tr><td></td><td></td><td>#include<deque></td><td>双端队列</td></tr><tr><td></td><td></td><td>#include<list></td><td>链表容器</td></tr><tr><td></td><td></td><td>#include<query></td><td>队列、优先队列</td></tr><tr><td></td><td></td><td>#include<stack></td><td>堆栈</td></tr><tr><td></td><td></td><td>#include<set></td><td>集合、多集合、位集合</td></tr><tr><td></td><td></td><td>#include<map></td><td>映射、多映射</td></tr><tr><td>6</td><td>通用算法</td><td>#include<algorithm></td><td></td></tr><tr><td>7</td><td>数值算法</td><td>#include<numeric></td><td></td></tr></tbody></table><p>STL的包含文件都不加拓展名，以便与C语言风格的“.h”头文件相区别</p><h2 id="1-2-命名空间"><a href="#1-2-命名空间" class="headerlink" title="1.2 命名空间"></a>1.2 命名空间</h2><p>STL程序中一般使用<code>using namespace std;</code>。</p><p>在 C++中,名称可以是变量、函数、结构、枚举以及类和结构的成员。随着工程的增大,名称相互冲突的可能性也将增加。使用多个厂商的类库时,可能导致名称冲突。例如两个库可能都定义了名为 func 的函数,但定义的方式不兼容,那么在应用中如何应用某个具体的func函数呢?C++提出了 namespace 命名空间解决方法,只要再加一层封装就可以了。</p><p>【例】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">namespace</span> mycompany&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,this is my company&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">namespace</span> yourcompany&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,this is your company&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mycompany;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    yourcompany::<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于STL命名空间名称是std，因此要应用STL，必须包含<code>using namespace std;</code></p><h1 id="第二章-模板"><a href="#第二章-模板" class="headerlink" title="第二章 模板"></a>第二章 模板</h1><p>模板提供通用的方法开发可重用的代码，即可创建参数化的C++类型。</p><p>模板分为：函数模板、类模板。</p><h2 id="2-1-traits-技术"><a href="#2-1-traits-技术" class="headerlink" title="2.1 traits 技术"></a>2.1 traits 技术</h2><p>traits中文意思是特性，提取不同类的共性，以便能统一处理。提取特性后用统一接口来包装。</p><p>【例】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CIntArray</span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CIntArray</span>()&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            a[i]=i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetSum</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            sum+=a[i];<br>        &#125;<br>        cout&lt;&lt;sum&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> sum*times;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFloatArray</span>&#123;<br>    <span class="hljs-type">float</span> f[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CFloatArray</span>()&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>            f[i<span class="hljs-number">-1</span>]=<span class="hljs-number">1.0f</span>/i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetSum</span><span class="hljs-params">(<span class="hljs-type">float</span> times)</span></span>&#123;<br>        <span class="hljs-type">float</span> sum=<span class="hljs-number">0.0f</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            sum+=f[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum*times;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    CIntArray intary;<br>    CFloatArray fltary;<br>    cout&lt;&lt;<span class="hljs-string">&quot;整型数组和3倍是：&quot;</span>&lt;&lt;intary.<span class="hljs-built_in">GetSum</span>(<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;浮点数组和3.2倍是：&quot;</span>&lt;&lt;fltary.<span class="hljs-built_in">GetSum</span>(<span class="hljs-number">3.2f</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码功能是把整型或浮点型数组的和乘以相应倍数并输出。能否使用一个类的接口函数完成上述功能？</p><p>使用类CApply</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CApply</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetSum</span><span class="hljs-params">(T &amp;t,<span class="hljs-type">float</span> inpara)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> t.<span class="hljs-built_in">GetSum</span>(inpara);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>main函数变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    CIntArray intary;<br>    CFloatArray fltary;<br>    CApply&lt;CIntArray&gt; c1;<br>    CApply&lt;CFloatArray&gt; c2;<br>    cout&lt;&lt;<span class="hljs-string">&quot;整型数组和3倍是：&quot;</span>&lt;&lt;c1.<span class="hljs-built_in">GetSum</span>(intary,<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;浮点数组和3.2倍是：&quot;</span>&lt;&lt;c2.<span class="hljs-built_in">GetSum</span>(fltary,<span class="hljs-number">3.2f</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过模板类CApply接口函数实现了对整型数组及浮点数组类的操作。</p><p>但有以下问题：CApply中GetSum把返回值固定成float，输入参数也固定成float，当int调用时，虽然结果上正确，但是不严谨。</p><p>traits技术用来解决输入、输出参数类型的不同。</p><p>步骤如下：</p><ol><li>定义基本模板类：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumTraits</span>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure>NumTraits可以什么内容都不写，仅说明该类是一个模板类</li><li>模板特化<br>针对CIntArray和CFloatArray，因此代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumTraits</span>&lt;CIntArray&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> resulttype;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> inputpara;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumTraits</span>&lt;CFloatArray&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> resulttype;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> inputpara;<br>&#125;;<br></code></pre></td></tr></table></figure>根据CIntArray类中函数int GetSum(int times)，将返回值int类型重新定义成resulttype，把输入int类型重新定义成intputpara。float同理。<br>目的为编制模板类共同的调用接口做准备。</li><li>统一模板调用类编制。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CApply</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    NumTraits&lt;T&gt;::<span class="hljs-function">resulttype <span class="hljs-title">GetSum</span><span class="hljs-params">(T&amp; obj,NumTraits&lt;T&gt;::inputpara in)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">GetSum</span>(in);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>当模板参数代表CIntArray，该定义变为如下代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">NumTraits&lt;CIntArray&gt;::<span class="hljs-function">resulttype <span class="hljs-title">GetSum</span><span class="hljs-params">(CIntArray &amp;obj,NumTraits&lt;CIntArray&gt;::inputpara in)</span></span><br></code></pre></td></tr></table></figure>为了简化CApply函数中定义形式，再次运用typedef进行定义，代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CApply</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> NumTraits&lt;T&gt;::resulttype result;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> NumTraits&lt;T&gt;::inputpara input;<br>    <span class="hljs-function">result <span class="hljs-title">GetSum</span><span class="hljs-params">(T&amp; obj,input in)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">GetSum</span>(in);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/11/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/11/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-线程与进程"><a href="#第二章-线程与进程" class="headerlink" title="第二章 线程与进程"></a>第二章 线程与进程</h1><p><strong>重点</strong></p><ol><li>进程与线程<br>进程与线程的基本概念；进程/线程的状态与转换<br>线程的实现：内核支持的线程，线程库支持的线程<br>进程与线程的组织与控制<br>进程间通信：共享内存，消息传递，管道</li></ol><h2 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h2><h3 id="2-1-1-进程的概念和特征"><a href="#2-1-1-进程的概念和特征" class="headerlink" title="2.1.1 进程的概念和特征"></a>2.1.1 进程的概念和特征</h3><h4 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1.进程的概念"></a>1.进程的概念</h4><ul><li><em><strong>进程控制块</strong></em>(Process Control Block,PCB):为使参与并发执行的每个程序（含数据）能独立运行，为之配置一个专门的数据结构。</li><li>系统利用PCB描述进程的基本情况和运行状态，进而控制和管理进程。</li><li><em><strong>进程实体</strong></em>（进程映像）由 程序段、相关数据段、PCB构成。</li><li>创建进程实质上是创建PCB，撤销进程也是撤销PCB。</li><li>进程映像是静态的，进程是动态的。</li><li>PCB是进程存在的唯一标志。</li></ul><p>进程概念定义为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong></p><p>对于系统资源的理解：应理解为设备服务于进程的“时间”，例如处理机资源理解为处理机的时间片。</p><h4 id="2-进程的特征"><a href="#2-进程的特征" class="headerlink" title="2.进程的特征"></a>2.进程的特征</h4><ol><li>动态性：进程是动态产生、变化和消亡的。</li><li>并发性：多个进程实体同存于内存中，能够在一段时间内同时运行。</li><li>独立性：进程是一个能独立运行、独立获得资源和独立接受调度的基本单位。</li><li>异步性：由于进程的相互制约，使得进程按各自独立、不可预知的速度向前推进，操作系统中必须配置相应的进程同步机制。</li></ol><h3 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1.2 进程的状态与转换"></a>2.1.2 进程的状态与转换</h3><p>进程在其生命周期内，由于各进程之间相互制约以及系统运行环境的变化，进程的状态也会不断变化。<br>会有以下五种状态，前三种是基本状态。</p><ol><li>运行态：单处理机中，每个时刻只有一个进程处于运行态</li><li>就绪态：进程获得了除处理机外的一切所需资源，一旦得到处理机就可立即运行。处于就绪态的进程可能有多个，通常排成一个队列，称为就绪队列。</li><li>阻塞态：又称等待态。进程正在等待某一事件而暂停运行，如等待某资源（不包括处理机）可用，如输入输出完成。根据阻塞原因不同，设置多个阻塞队列。</li><li>创建态：进程正在被创建，尚未转到就绪态。<br>创建进程的步骤：<ul><li>申请空白PCB，写入控制和管理进程的信息。</li><li>分配运行时必须的资源。</li><li>转入就绪态并插入就绪队列。</li><li>如果所需资源尚不能满足，例如内存不足，则创建工作未完成，所处状态为创建态</li></ul></li><li>结束态：进程正从系统中消失。进程因正常结束或其他原因推出运行，先设置为结束态，然后处理资源释放和回收工作。</li></ol><p>3种基本状态之间转换如下：</p><ul><li>就绪态-&gt;运行态:就绪态获得处理机资源（分配处理机时间片）后转为运行态。</li><li>运行态-&gt;就绪态：运行态时间片用完后后，让出处理机，转为就绪态。当在可剥夺的操作系统中，有更高级的进程就绪时，调度程序将正在执行的程序转为就绪态，让更高优先级进程执行。</li><li>运行态-&gt;阻塞态：进程请求某一资源（如外设）的使用和分配等待某一事件的发生（如I/O操作的完成）时，就从运行态转为阻塞态。</li><li>阻塞态-&gt;就绪态：进程等待事件的到来时，如I/O操作结束或中断结束时，中断处理程序把相应进程状态从阻塞态转换为就绪态。</li></ul><p>进程从运行态到阻塞态时主动行为，而从阻塞态到就绪态时被动行为，需要其他相关进程协助。</p><h3 id="2-1-3-进程的组织"><a href="#2-1-3-进程的组织" class="headerlink" title="2.1.3 进程的组织"></a>2.1.3 进程的组织</h3><p>进程是一个独立运行的单位，也是操作系统进行资源分配和调度的基本单位。由以下三部分组成：</p><h4 id="1-进程控制块PCB"><a href="#1-进程控制块PCB" class="headerlink" title="1.进程控制块PCB"></a>1.进程控制块PCB</h4><p>进程创建，操作系统分配一个PCB，常驻内存，并在进程结束后删除。PCB是进程实体的一部分，是进程存在的唯一标志。</p><p>操作系统调度某进程运行时：</p><ul><li>从PCB中查出现行状态与优先级</li><li>调度到某进程后，根据PCB中保存的处理机状态信息，设置该进程恢复运行的线程，并根据程序和数据的内存始址，找到程序与数据。</li><li>进程运行中，当需要与之合作的进程实现同步、通信或访问文件时，也需要访问PCB</li><li>某种原因暂停运行时，需要将其断点的处理机环境保存至PCB中。</li></ul><p>系统是通过PCB对进程进行控制的，系统只有通过进程的PCB才能感知到该进程存在。</p><table><thead><tr><th>进程描述信息</th><th>进程控制和管理信息</th><th>资源分配清单</th><th>处理机相关信息</th></tr></thead><tbody><tr><td>进程标识符(PID)</td><td>进程当前状态</td><td>代码段指针</td><td>通用寄存器值</td></tr><tr><td>用户标识符(UID)</td><td>进程优先级</td><td>数据段指针</td><td>地址寄存器值</td></tr><tr><td></td><td>代码运行入口地址</td><td>堆栈段指针</td><td>控制寄存器值</td></tr><tr><td></td><td>程序的外存地址</td><td>文件描述符</td><td>标志寄存器值</td></tr><tr><td></td><td>进入内存时间</td><td>键盘</td><td>状态字</td></tr><tr><td></td><td>处理机占用时间</td><td>鼠标</td><td></td></tr><tr><td></td><td>信号量使用</td><td></td><td></td></tr></tbody></table><ol><li>进程描述信息。PID：标志唯一进程。UID：进程归属用户，主要为共享和保护服务。</li><li>进程控制和管理信息。</li><li>资源分配清单，用于描述有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入输出设备信息。</li><li>处理机相关信息，又称处理机的上下文，主要指处理机中各寄存器的值。进程处于执行态时，处理机许多信息存在寄存器中，当进程切换，处理机状态新信息都必须保存至相应PCB中，以便重新执行时，能从断电继续执行。</li></ol><p>为方便调度各进程PCB，常见组织方式为：链接方式和索引方式两种。</p><ul><li>链接方式：将同一状态的PCB链接成一个队列，不同状态不同队列，阻塞态根据原因不同，排成多个阻塞队列。</li><li>索引方式：同状态进程存在一个索引表中，表项指向相应的PCB，不同状态对应不同索引表。</li></ul><h4 id="2-程序段"><a href="#2-程序段" class="headerlink" title="2.程序段"></a>2.程序段</h4><p>就是能被进程调度程序调度到CPU执行的程序代码段，多个进程可运行同一个程序</p><h4 id="3-数据段"><a href="#3-数据段" class="headerlink" title="3.数据段"></a>3.数据段</h4><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><h3 id="2-1-4-进程控制"><a href="#2-1-4-进程控制" class="headerlink" title="2.1.4 进程控制"></a>2.1.4 进程控制</h3><p>一般把进程控制用的程序段称为<em><strong>原语</strong></em>，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p><h4 id="1-进程的创建"><a href="#1-进程的创建" class="headerlink" title="1.进程的创建"></a>1.进程的创建</h4><p>允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。</p><p>子进程可以继承父进程所拥有的资源，当子进程被撤销时，归还从父进程获得的资源。</p><p>撤销父进程时，通常会同时撤销子进程。</p><p>操作系统创建一个新进程的过程如下（创建原语）：</p><ol><li>为新进程分配一个唯一的PID，并申请一个空白PCB（PCB是有限的）。若PCB申请失败，则创建失败。</li><li>分配所需资源。从操作系统或仅从父进程获得，如资源不足，处于创建态，等待资源。</li><li>初始化PCB，初始化标志信息、处理机状态信息、处理机控制信息、设置进程的优先级。</li><li>若进程就绪队列能接纳新进程，新进程就插入就绪队列，等待被调度运行。</li></ol><h4 id="2-进程的终止"><a href="#2-进程的终止" class="headerlink" title="2.进程的终止"></a>2.进程的终止</h4><p>引起终止的事件主要有：</p><ul><li>正常结束，进程任务完成</li><li>异常结束，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O故障等</li><li>外界干预，指进程应外界请求终止，如操作员或操作系统干预、父进程请求和父进程终止。</li></ul><p>操作系统终止进程的过程如下（终止原语）：</p><ol><li>根据被终止进程的PID，检索出该进程PCB，读出进程状态</li><li>若进程处于执行状态，则立即终止进程的执行，将处理机资源分配给其他进程</li><li>若该进程还有子孙进程，一并终止</li><li>将进程所拥有全部资源，归还父进程或归还操作系统</li><li>将PCB从所在队列（链表）中删除</li></ol><h4 id="3-进程的阻塞和唤醒"><a href="#3-进程的阻塞和唤醒" class="headerlink" title="3.进程的阻塞和唤醒"></a>3.进程的阻塞和唤醒</h4><p>正在执行的程序，因某些期待事件未发生，如请求系统资源失败、等待某种操作完成、新数据尚未到达或无进任务做等，便调用阻塞原语(Block)，改变运行态为阻塞态。</p><p>阻塞是进程自身的一种主动行为，只有处于运行态的进程（获得CPU），才能将其转为阻塞态。</p><p>阻塞原语的执行过程如下：</p><ol><li>找到PID对应的PCB</li><li>若为运行态，则保护现场，转为阻塞态，停止运行</li><li>将PCB插入相应事件的等待队列，将处理器资源调度给其他就绪进程</li></ol><p>当被阻塞进程所期待事件出现时（如它所启动的I/O操作已完成，或所期待的数据已到达），由有关进程（释放该I/O设备的进程，或提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。</p><p>唤醒原语的执行过程如下：</p><ol><li>在该事件的等待队列中找到相应进程的PCB</li><li>将其从等待队列中移出，并置为就绪态</li><li>把该PCB插入就绪队列，等待调度程序调度</li></ol><blockquote><p>Block与Wakeup是一对作用相反的原语，必须成对使用。如果某进程中调用了Block原语，则必须在与之合作的或其他的相关进程中安排一条相应的Wakeup原语，一边唤醒阻塞进程，否则，阻塞进程会因不能被唤醒而永久处于阻塞状态。</p></blockquote><h3 id="2-1-5-进程的通信"><a href="#2-1-5-进程的通信" class="headerlink" title="2.1.5 进程的通信"></a>2.1.5 进程的通信</h3><p>进程通信是指进程之间的信息交换，PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类：</p><h4 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1.共享存储"></a>1.共享存储</h4><p>通信进程之间建立一块可直接访问的共享空间，实现进程之间的信息交换。在对共享空间进行读/写操作时，需要使用同步互斥工具（如P操作、V操作），对共享空间的写/读进行控制。</p><p>共享存储又分两种：</p><ul><li>低级方式的共享是基于数据结构的共享</li><li>高级方式基于存储区的共享</li></ul><p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换由用户自己安排读/写指令完成。</p><blockquote><p>进程空间一般是独立的，进程运行期间一般不能访问其他进程的空间，两个进程共享空间必须通过特殊的系统调用实现，进而进程内的线程是自然共享进程空间的。</p></blockquote><h4 id="2-消息传递"><a href="#2-消息传递" class="headerlink" title="2.消息传递"></a>2.消息传递</h4><p>消息传递系统中，进程间的数据交换以格式化消息(Message)为单位。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法进行通信。进程之间通过发送消息和接收消息两个原语进行数据交换。</p><p>这种方式隐藏了通信实现的细节，使通信过程对用户透明，简化了通信程序的设计。</p><ol><li>直接通信方式：发送进程直接发送消息给接收进程，并将它挂在接收进程的消息缓冲队列，接收进程从消息缓冲队列中取得消息。</li><li>间接通信方式：发送进程将消息发送到某个中间实体，接收进程从中间实体取得消息，这种中间实体一般称为<em>信箱</em>，该通信方式广泛应用于计算机网络中。</li></ol><h4 id="3-管道通信"><a href="#3-管道通信" class="headerlink" title="3.管道通信"></a>3.管道通信</h4><p>管道是一种特殊的共享文件(pipe文件)，发送进程以字符流形式将数据送入（写）管道，而接收方从管道中接受（读）管道。为协调双方通信，管道必须具有以下三方面协调能力：互斥、同步、确定对方存在。<br>Linux中，管道是一种使用非常频繁的通信机制，管道可以克服使用文件进行通信的两个问题：</p><ol><li>限制管道的大小。管道是一个固定大小的缓冲区，Linux该缓冲区的大小为4KB。写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认被阻塞，等待数据读取，以便腾出空间供write()调用写。</li><li>读可能比写快，当所有数据被读，管道变空，这种情况发生时，一个随后的read()调用将默认被阻塞，等待数据写入，解决了read()调用返回文件结束的问题。</li></ol><blockquote><p>从管道中读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。<br>管道只能采用半双工通信，即某一时刻只能单向传输，要实现父子进程互动通信，需定义两个管道。</p></blockquote><p>在管道通信中，存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区中有数据，进程就能从缓冲区读出，不必担心会因为其他进程在其中进行写操作而遭到阻塞。因为写进程会先把缓冲区写满，然后才让读进程读。当缓冲区还有数据时，写进程不会往缓冲区写数据。这也决定了管道通信必然是半双工通信。</p><h3 id="2-1-6-线程和多线程模型"><a href="#2-1-6-线程和多线程模型" class="headerlink" title="2.1.6 线程和多线程模型"></a>2.1.6 线程和多线程模型</h3><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言简明</title>
    <link href="/2022/11/21/C%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E/"/>
    <url>/2022/11/21/C%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C 程序结构"></a>C 程序结构</h1><p>在我们学习 C 语言的基本构建块之前，让我们先来看看一个最小的 C 程序结构，在接下来的章节中可以以此作为参考。</p><h2 id="C-Hello-World-实例"><a href="#C-Hello-World-实例" class="headerlink" title="C Hello World 实例"></a>C Hello World 实例</h2><p>C 程序主要包括以下部分：</p><ul><li>预处理器指令</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><p>让我们看一段简单的代码，可以输出单词 “Hello World”：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* 我的第一个 C 程序 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World! \n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们讲解一下上面这段程序：</p><ol><li> 程序的第一行 <code>#include &lt;stdio.h&gt;</code> 是预处理器指令，告诉 C 编译器在实际编译之前要包含 <code>stdio.h</code> 文件。</li><li> 下一行 <code>int main()</code> 是主函数，程序从这里开始执行。</li><li> 下一行 <code>/*...*/</code> 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。</li><li> 下一行 <code>printf(...)</code> 是 C 中另一个可用的函数，会在屏幕上显示消息 <code>&quot;Hello, World!&quot;</code>。</li><li> 下一行 <code>return 0;</code> 终止 <code>main()</code> 函数，并返回值 0。</li></ol><h2 id="编译-amp-执行-C-程序"><a href="#编译-amp-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C 程序"></a>编译 &amp; 执行 C 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p><ol><li> 打开一个文本编辑器，添加上述代码。</li><li> 保存文件为 <code>hello.c</code>。</li><li> 打开命令提示符，进入到保存文件所在的目录。</li><li> 键入 <code>gcc hello.c</code>，输入回车，编译代码。</li><li> 如果代码中没有错误，命令提示符会跳到下一行，并生成 <em>a.out</em> 可执行文件。</li><li> 现在，键入 <code>a.out</code> 来执行程序。</li><li> 您可以看到屏幕上显示 <code>&quot;Hello World&quot;</code>。</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc hello.c<br><span class="hljs-variable">$ </span>./a.<span class="hljs-keyword">out</span><br>Hello, World!<br></code></pre></td></tr></table></figure><p>请确保您的路径中已包含 gcc 编译器，并确保在包含源文件 <code>hello.c</code> 的目录中运行它。</p><p>如果是多个 c 代码的源码文件，编译方法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ gcc test1<span class="hljs-selector-class">.c</span> test2<span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.out</span><br>$ ./<span class="hljs-selector-tag">main</span>.out<br></code></pre></td></tr></table></figure><p>test1.c 与 test2.c 是两个源代码文件。</p><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C 基本语法"></a>C 基本语法</h1><p>我们已经看过 C 程序的基本结构，这将有助于我们理解 C 语言的其他基本的构建块。</p><h2 id="C-的令牌（Token）"><a href="#C-的令牌（Token）" class="headerlink" title="C 的令牌（Token）"></a>C 的令牌（Token）</h2><p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World! \n&quot;</span>);<br></code></pre></td></tr></table></figure><p>这五个令牌分别是：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">printf<br>(<br><span class="hljs-string">&quot;Hello, World! \n&quot;</span><br>)<br><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="分号"><a href="#分号" class="headerlink" title="分号 ;"></a>分号 ;</h2><p>在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p><p>例如，下面是两个不同的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World! \n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>C 语言有两种注释方式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 单行注释</span><br></code></pre></td></tr></table></figure><p>以 // 开始的单行注释，这种注释可以单独占一行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 单行注释 */</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>/* */ 这种格式的注释可以单行或多行。</p><p>您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p><p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，<code>_Manpower_</code> 和 <code>_manpower_</code> 是两个不同的标识符。下面列出几个有效的标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">mohd zara abc move_name a_123<br>myname50 \_temp j a23b9 retVal<br></code></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>声明自动变量</td></tr><tr><td>break</td><td>跳出当前循环</td></tr><tr><td>case</td><td>开关语句分支</td></tr><tr><td>char</td><td>声明字符型变量或函数返回值类型</td></tr><tr><td>const</td><td>定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td></tr><tr><td>continue</td><td>结束当前循环，开始下一轮循环</td></tr><tr><td>default</td><td>开关语句中的”其它”分支</td></tr><tr><td>do</td><td>循环语句的循环体</td></tr><tr><td>double</td><td>声明双精度浮点型变量或函数返回值类型</td></tr><tr><td>else</td><td>条件语句否定分支（与 if 连用）</td></tr><tr><td>enum</td><td>声明枚举类型</td></tr><tr><td>extern</td><td>声明变量或函数是在其它文件或本文件的其他位置定义</td></tr><tr><td>float</td><td>声明浮点型变量或函数返回值类型</td></tr><tr><td>for</td><td>一种循环语句</td></tr><tr><td>goto</td><td>无条件跳转语句</td></tr><tr><td>if</td><td>条件语句</td></tr><tr><td>int</td><td>声明整型变量或函数</td></tr><tr><td>long</td><td>声明长整型变量或函数返回值类型</td></tr><tr><td>register</td><td>声明寄存器变量</td></tr><tr><td>return</td><td>子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td>short</td><td>声明短整型变量或函数</td></tr><tr><td>signed</td><td>声明有符号类型变量或函数</td></tr><tr><td>sizeof</td><td>计算数据类型或变量长度（即所占字节数）</td></tr><tr><td>static</td><td>声明静态变量</td></tr><tr><td>struct</td><td>声明结构体类型</td></tr><tr><td>switch</td><td>用于开关语句</td></tr><tr><td>typedef</td><td>用以给数据类型取别名</td></tr><tr><td>unsigned</td><td>声明无符号类型变量或函数</td></tr><tr><td>union</td><td>声明共用体类型</td></tr><tr><td>void</td><td>声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td>volatile</td><td>说明变量在程序执行中可被隐含地改变</td></tr><tr><td>while</td><td>循环语句的循环条件</td></tr></tbody></table><h3 id="C99-新增关键字"><a href="#C99-新增关键字" class="headerlink" title="C99 新增关键字"></a>C99 新增关键字</h3><table class="reference"><tbody><tr><td><tt>_Bool</tt></td><td><tt>_Complex</tt></td><td><tt>_Imaginary</tt></td><td><tt>inline</tt></td><td><tt>restrict</tt></td></tr></tbody></table><h3 id="C11-新增关键字"><a href="#C11-新增关键字" class="headerlink" title="C11 新增关键字"></a>C11 新增关键字</h3><table class="reference"><tbody><tr><td><tt>_Alignas</tt></td><td><tt>_Alignof</tt></td><td><tt>_Atomic</tt></td><td><tt>_Generic</tt></td><td><tt>_Noreturn</tt></td></tr><tr><td><tt>_Static_assert</tt></td><td><tt>_Thread_local</tt></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table><h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C 中的空格"></a>C 中的空格</h2><p>只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。</p><p>在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> age;<br></code></pre></td></tr></table></figure><p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">fruit = apples + oranges; <span class="hljs-comment">// 获取水果的总数</span><br></code></pre></td></tr></table></figure><p><code>fruit</code> 和 <code>=</code>，或者 <code>=</code> 和 <code>apples</code> 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p><h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C 数据类型"></a>C 数据类型</h1><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>C 中的类型可分为以下几种：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>基本类型：</strong></td><td>它们是算术类型，包括两种类型：整数类型和浮点类型。</td></tr><tr><td><strong>枚举类型：</strong></td><td>它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td></tr><tr><td><strong>void 类型：</strong></td><td>类型说明符 <em>void</em> 表明没有可用的值。</td></tr><tr><td><strong>派生类型：</strong></td><td>它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td></tr></tbody></table><p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。在本章节接下来的部分我们将介绍基本类型，其他几种类型会在后边几个章节中进行讲解。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td>char</td><td>1 字节</td><td>-128 到 127 或 0 到 255</td></tr><tr><td>unsigned char</td><td>1 字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>2 或 4 字节</td><td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned int</td><td>2 或 4 字节</td><td>0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td>short</td><td>2 字节</td><td>-32,768 到 32,767</td></tr><tr><td>unsigned short</td><td>2 字节</td><td>0 到 65,535</td></tr><tr><td>long</td><td>4 字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4 字节</td><td>0 到 4,294,967,295</td></tr></tbody></table><blockquote><p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。</p><p>以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：</p><p><img src="https://blog.yoobit.cn/img_out/C_LEARN/32-64.jpg"></p></blockquote><p>为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 <strong>sizeof</strong> 运算符。表达式 <code>sizeof(type)</code> 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int 存储大小 : %lu \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>%lu</strong> 为 32 位无符号整数，详细说明查看 <a href="./#printf">库函数 - printf()</a>。</p><p>当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> 存储大小 : <span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位有效位</td></tr><tr><td>double</td><td>8 字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位有效位</td></tr><tr><td>long double</td><td>16 字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19 位有效位</td></tr></tbody></table><p>头文件 <code>float.h</code> 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值：</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;float.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;float 存储最大字节数 : %lu \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;float 最小值: %E\n&quot;</span>, FLT_MIN ); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;float 最大值: %E\n&quot;</span>, FLT_MAX ); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;精度值: %d\n&quot;</span>, FLT_DIG ); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>%E</strong> 为以指数形式输出单、双精度实数，详细说明查看 <a href="https://blog.yoobit.cn/img_out/C_LEARN/c-function-printf.html">C 库函数 - printf()</a>。</p><p>当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">float 存储最大字节数</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">4</span><br><br><span class="hljs-attribute">float 最小值</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1.175494E-38</span><br><br><span class="hljs-attribute">float 最大值</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3.402823E+38</span><br><br><span class="hljs-attribute">精度值</span><span class="hljs-punctuation">:</span> <span class="hljs-string">6</span><br></code></pre></td></tr></table></figure><h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>函数返回为空</strong></td><td>C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td></tr><tr><td><strong>函数参数为空</strong></td><td>C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td></tr><tr><td><strong>指针指向 void</strong></td><td>类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><p>如果现在您还是无法完全理解 void 类型，不用太担心，在后续的章节中我们将会详细讲解这些概念。</p><h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h1><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p><p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>通常是一个字节（八位）, 这是一个整数类型。</td></tr><tr><td>int</td><td>整型，4 个字节，取值范围 -2147483648 到 2147483647。</td></tr><tr><td>float</td><td>单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。<img src="https://blog.yoobit.cn/img_out/C_LEARN/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png"></td></tr><tr><td>double</td><td>双精度浮点值。双精度是1位符号，11位指数，52位小数。<img src="https://blog.yoobit.cn/img_out/C_LEARN/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png"></td></tr><tr><td>void</td><td>表示类型的缺失。</td></tr></tbody></table><p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等，这将会在后续的章节中进行讲解，本章节我们先讲解基本变量类型。</p><h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C 中的变量定义"></a>C 中的变量定义</h2><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">type variable_list;<br></code></pre></td></tr></table></figure><p>在这里，<strong>type</strong> 必须是一个有效的 C 数据类型，可以是 <code>char</code>、<code>w_char</code>、<code>int</code>、<code>float</code>、<code>double</code> 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span>    i, j, k;<br><span class="hljs-type">char</span>   c, ch;<br><span class="hljs-type">float</span>  f, salary;<br><span class="hljs-type">double</span> d;<br></code></pre></td></tr></table></figure><p>行 <strong>int i, j, k;</strong> 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。</p><p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">type variable_name = value;<br></code></pre></td></tr></table></figure><p>下面列举几个实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> d = <span class="hljs-number">3</span>, f = <span class="hljs-number">5</span>;    <span class="hljs-comment">// d 和 f 的声明与初始化</span><br><span class="hljs-type">int</span> d = <span class="hljs-number">3</span>, f = <span class="hljs-number">5</span>;           <span class="hljs-comment">// 定义并初始化 d 和 f</span><br>byte z = <span class="hljs-number">22</span>;                <span class="hljs-comment">// 定义并初始化 z</span><br><span class="hljs-type">char</span> x = <span class="hljs-string">&#x27;x&#x27;</span>;               <span class="hljs-comment">// 变量 x 的值为 &#x27;x&#x27;</span><br></code></pre></td></tr></table></figure><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p><h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C 中的变量声明"></a>C 中的变量声明</h2><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p><p>变量的声明有两种情况：</p><ul><li>  1、一种是需要建立存储空间的。例如：<code>int a</code> 在声明的时候就已经建立了存储空间。</li><li>  2、另一种是不需要建立存储空间的，通过使用<code>extern</code>关键字声明变量名而不定义它。 例如：<code>extern int a</code> 其中变量 a 可以在别的文件中定义的。</li><li>  除非有<code>extern</code>关键字，否则都是变量的定义。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">//声明，不是定义</span><br><span class="hljs-type">int</span> i; <span class="hljs-comment">//声明，也是定义</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// 函数外定义变量 x 和 y int x; int y;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">addtwonum</span><span class="hljs-params">()</span><br>&#123; <span class="hljs-comment">// 函数内声明变量 x 和 y 为外部变量 </span><br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> y; <span class="hljs-comment">// 给外部变量（全局变量）x 和 y 赋值 </span><br>    x = <span class="hljs-number">1</span>;<br>    y = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123;   <span class="hljs-type">int</span> result; <span class="hljs-comment">// 调用函数 addtwonum</span><br>    result = addtwonum();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result 为: %d&quot;</span>,result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">result 为: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 <code>extern</code> 关键字的声明即可。</p><h3 id="addtwonum-c-文件代码："><a href="#addtwonum-c-文件代码：" class="headerlink" title="addtwonum.c 文件代码："></a>addtwonum.c 文件代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">/*外部变量声明*/</span> </span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x ;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> y ;<br><span class="hljs-type">int</span> <span class="hljs-title function_">addtwonum</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="test-c-文件代码："><a href="#test-c-文件代码：" class="headerlink" title="test.c 文件代码："></a>test.c 文件代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">/*定义两个全局变量*/</span></span><br><span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> y=<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">addtwonum</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> result;<br>    result = addtwonum();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result 为: %d\n&quot;</span>,result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ gcc addtwonum<span class="hljs-selector-class">.c</span> test<span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span><br>$ ./<span class="hljs-selector-tag">main</span><br>result 为: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C 中的左值（Lvalues）和右值（Rvalues）"></a>C 中的左值（Lvalues）和右值（Rvalues）</h2><p>C 中有两种类型的表达式：</p><ol><li> <strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li><li> <strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ol><p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> g = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">10</span> = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C 常量"></a>C 常量</h1><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p><p>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。</p><p><strong>常量</strong>就像是常规的变量，只不过常量的值在定义后不能进行修改。</p><h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：<code>0x</code> 或 <code>0X</code> 表示十六进制，<code>0</code> 表示八进制，不带前缀则默认表示十进制。</p><p>整数常量也可以带一个后缀，后缀是 <code>U</code> 和 <code>L</code> 的组合，<code>U</code> 表示无符号整数（<code>unsigned</code>），<code>L</code> 表示长整数（<code>long</code>）。后缀可以是大写，也可以是小写，<code>U</code> 和 <code>L</code> 的顺序任意。</p><p>下面列举几个整数常量的实例：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">212 </span>        /* 合法的 */<br><span class="hljs-number">215</span>u        /* 合法的 */<br><span class="hljs-number">0</span>xFeeL      /* 合法的 */<br><span class="hljs-symbol">078 </span>        /* 非法的：<span class="hljs-number">8</span> 不是八进制的数字 */<br><span class="hljs-number">032</span>UU       /* 非法的：不能重复后缀 */<br></code></pre></td></tr></table></figure><p>以下是各种类型的整数常量的实例：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">85 </span>        /* 十进制 */<br><span class="hljs-symbol">0213 </span>      /* 八进制 */<br><span class="hljs-number">0</span>x4b       /* 十六进制 */<br><span class="hljs-symbol">30 </span>        /* 整数 */<br><span class="hljs-number">30</span>u        /* 无符号整数 */<br><span class="hljs-number">30</span>l        /* 长整数 */<br><span class="hljs-number">30</span>ul       /* 无符号长整数 */<br></code></pre></td></tr></table></figure><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p><p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p><p>下面列举几个浮点常量的实例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">3.14159</span>       <span class="hljs-regexp">/* 合法的 */</span><br><span class="hljs-number">314159</span>E-<span class="hljs-number">5</span>L    <span class="hljs-regexp">/* 合法的 */</span><br><span class="hljs-number">510</span>E          <span class="hljs-regexp">/* 非法的：不完整的指数 */</span><br><span class="hljs-number">210</span>f          <span class="hljs-regexp">/* 非法的：没有小数或指数 */</span><br>.e55          <span class="hljs-regexp">/* 非法的：缺少整数或分数 */</span><br></code></pre></td></tr></table></figure><h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><p>字符常量是括在单引号中，例如，<code>x</code> 可以存储在 <strong>char</strong> 类型的简单变量中。</p><p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 <code>\t</code>），或一个通用的字符（例如 <code>\u02C0</code>）。</p><p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（<code>\n</code>）或制表符（<code>\t</code>）等。下表列出了一些这样的转义序列码：</p><table><thead><tr><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td>\\</td><td>\ 字符</td></tr><tr><td>\‘</td><td>‘ 字符</td></tr><tr><td>\“</td><td>“ 字符</td></tr><tr><td>\?</td><td>? 字符</td></tr><tr><td>\a</td><td>警报铃声</td></tr><tr><td>\b</td><td>退格键</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\ooo</td><td>一到三位的八进制数</td></tr><tr><td>\xhh . . .</td><td>一个或多个数字的十六进制数</td></tr></tbody></table><p>下面的实例显示了一些转义序列字符：</p><h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\tWorld\n\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hello   World</span><br></code></pre></td></tr></table></figure><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p><p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p><p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;hello, dear&quot;</span><br><br><span class="hljs-string">&quot;hello, \</span><br><br>dear<span class="hljs-string">&quot;</span><br><br><span class="hljs-string">&quot;hello, &quot;</span> <span class="hljs-string">&quot;d&quot;</span> <span class="hljs-string">&quot;ear&quot;</span><br></code></pre></td></tr></table></figure><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>在 C 中，有两种简单的定义常量的方式：</p><ol><li> 使用 <strong>#define</strong> 预处理器。</li><li> 使用 <strong>const</strong> 关键字。</li></ol><h3 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h3><p>下面是使用 #define 预处理器定义常量的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> identifier value</span><br></code></pre></td></tr></table></figure><p>具体请看下面的实例：</p><h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIDTH 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWLINE <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> area;<br>    area = LENGTH * WIDTH;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;value of area : %d&quot;</span>, area);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, NEWLINE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">value <span class="hljs-keyword">of</span> area : 50<br></code></pre></td></tr></table></figure><h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const type variable <span class="hljs-operator">=</span> value<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="https://blog.yoobit.cn/img_out/C_LEARN/c-const-2021-01-15.png"></p><p>const 声明常量要在一个语句内完成：</p><p><img src="https://blog.yoobit.cn/img_out/C_LEARN/c-const-2021-01-15-2.png"></p><p>具体请看下面的实例：</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> LENGTH = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> WIDTH = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> NEWLINE = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-type">int</span> area;<br>    area = LENGTH * WIDTH;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;value of area : %d&quot;</span>, area);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, NEWLINE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><pre><code class="hljs">value of area : 50</code></pre><p>请注意，把常量定义为大写字母形式，是一个很好的编程习惯。</p><h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h1><p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p><ul><li>  auto</li><li>  register</li><li>  static</li><li>  extern</li></ul><h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2><p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">&#123;<br>   <span class="hljs-type">int</span> mount;<br>   <span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> month;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的实例定义了两个带有相同存储类的变量，<code>auto</code> 只能用在函数内，即 <code>auto</code> 只能修饰局部变量。</p><h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 <code>RAM</code> 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">&#123;<br>   <span class="hljs-keyword">register</span> <span class="hljs-type">int</span>  miles;<br>&#125;<br></code></pre></td></tr></table></figure><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 <code>register</code> 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 <code>static</code> 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p><code>static</code> 修饰符也可以应用于全局变量。当 <code>static</code> 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>全局声明的一个 <code>static</code> 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 <code>static</code> 变量或方法同一个文件中。</p><p>以下实例演示了 <code>static</code> 修饰全局变量和局部变量的应用：</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">/* 函数声明 */</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count=<span class="hljs-number">10</span>; <span class="hljs-comment">/* 全局变量 - static 是默认的 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (count--)<br>    &#123;<br>        func1();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>    &#123;<br>    <span class="hljs-comment">/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次</span><br><span class="hljs-comment">    * 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> thingy=<span class="hljs-number">5</span>;<br>    thingy++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; thingy 为 %d ， count 为 %d\n&quot;</span>, thingy,count);<br>&#125;<br></code></pre></td></tr></table></figure><p>实例中 <code>count</code> 作为全局变量可以在函数内使用，<code>thingy</code> 使用 <code>stati</code> 修饰后，不会在每次调用时重置。</p><p>可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">6</span> ， count 为 <span class="hljs-number">9</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">7</span> ， count 为 <span class="hljs-number">8</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">8</span> ， count 为 <span class="hljs-number">7</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">9</span> ， count 为 <span class="hljs-number">6</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">10</span> ， count 为 <span class="hljs-number">5</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">11</span> ， count 为 <span class="hljs-number">4</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">12</span> ， count 为 <span class="hljs-number">3</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">13</span> ， count 为 <span class="hljs-number">2</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">14</span> ， count 为 <span class="hljs-number">1</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">15</span> ， count 为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <code>extern</code> 来得到已定义的变量或函数的引用。可以这么理解，<code>extern</code> 是用来在另一个文件中声明一个全局变量或函数。</p><p><code>extern</code> 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><h3 id="实例-第一个文件：main-c"><a href="#实例-第一个文件：main-c" class="headerlink" title="实例 第一个文件：main.c"></a>实例 第一个文件：main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> count ;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">write_extern</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    count = <span class="hljs-number">5</span>;<br>    write_extern();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例-第二个文件：support-c"><a href="#实例-第二个文件：support-c" class="headerlink" title="实例 第二个文件：support.c"></a>实例 第二个文件：support.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> count;<br><span class="hljs-type">void</span> <span class="hljs-title function_">write_extern</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，第二个文件中的 <code>extern</code> 关键字用于声明已经在第一个文件 main.c 中定义的 <code>count</code>。现在 ，编译这两个文件，如下所示：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ gcc main.c sup<span class="hljs-keyword">port</span>.c<br></code></pre></td></tr></table></figure><p>这会产生 <strong>a.out</strong> 可执行程序，当程序被执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">count is <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C 运算符"></a>C 运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p><ul><li>  算术运算符</li><li>  关系运算符</li><li>  逻辑运算符</li><li>  位运算符</li><li>  赋值运算符</li><li>  杂项运算符</li></ul><p>本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表显示了 C 语言支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>把两个操作数相加</td><td>A + B 将得到 30</td></tr><tr><td>-</td><td>从第一个操作数中减去第二个操作数</td><td>A - B 将得到 -10</td></tr><tr><td>*</td><td>把两个操作数相乘</td><td>A * B 将得到 200</td></tr><tr><td>/</td><td>分子除以分母</td><td>B / A 将得到 2</td></tr><tr><td>%</td><td>取模运算符，整除后的余数</td><td>B % A 将得到 0</td></tr><tr><td>++</td><td>自增运算符，整数值增加 1</td><td>A++ 将得到 11</td></tr><tr><td>--</td><td>自减运算符，整数值减少 1</td><td>A– 将得到 9</td></tr></tbody></table><h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>请看下面的实例，了解 C 语言中所有可用的算术运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123; <br>    <span class="hljs-type">int</span> a = <span class="hljs-number">21</span>; <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>; <span class="hljs-type">int</span> c ; c = a + b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );<br>    c = a - b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - c 的值是 %d\n&quot;</span>, c );<br>    c = a * b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );<br>    c = a / b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 4 - c 的值是 %d\n&quot;</span>, c );<br>    c = a % b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );<br>    c = a++;    <span class="hljs-comment">// 赋值后再加 1 ，c 为 21，a 为 22</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 6 - c 的值是 %d\n&quot;</span>, c );<br>    c = a--; <span class="hljs-comment">// 赋值后再减 1 ，c 为 22 ，a 为 21</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 7 - c 的值是 %d\n&quot;</span>, c );<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">Line <span class="hljs-number">1</span> - c 的值是 <span class="hljs-number">31</span><br>Line <span class="hljs-number">2</span> - c 的值是 <span class="hljs-number">11</span><br>Line <span class="hljs-number">3</span> - c 的值是 <span class="hljs-number">210</span><br>Line <span class="hljs-number">4</span> - c 的值是 <span class="hljs-number">2</span><br>Line <span class="hljs-number">5</span> - c 的值是 <span class="hljs-number">1</span><br>Line <span class="hljs-number">6</span> - c 的值是 <span class="hljs-number">21</span><br>Line <span class="hljs-number">7</span> - c 的值是 <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>以下实例演示了 a++ 与 ++a 的区别：</p><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    c = a++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;先赋值后运算：\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - a 的值是 %d\n&quot;</span>, a );<br>    a = <span class="hljs-number">10</span>;<br>    c = a\--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 4 - a 的值是 %d\n&quot;</span>, a );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;先运算后赋值：\n&quot;</span>);<br>    a = <span class="hljs-number">10</span>;<br>    c = ++a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 6 - a 的值是 %d\n&quot;</span>, a );<br>    a = <span class="hljs-number">10</span>;<br>    c = --a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 7 - c 的值是 %d\n&quot;</span>, c );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 8 - a 的值是 %d\n&quot;</span>, a );<br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序执行输出结果为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">先赋值后运算：<br><span class="hljs-built_in">Line</span> <span class="hljs-number">1</span> <span class="hljs-operator">-</span> <span class="hljs-variable">c</span> 的值是 <span class="hljs-number">10</span><br><span class="hljs-built_in">Line</span> <span class="hljs-number">2</span> <span class="hljs-operator">-</span> <span class="hljs-variable">a</span> 的值是 <span class="hljs-number">11</span><br><span class="hljs-built_in">Line</span> <span class="hljs-number">3</span> <span class="hljs-operator">-</span> <span class="hljs-variable">c</span> 的值是 <span class="hljs-number">10</span><br><span class="hljs-built_in">Line</span> <span class="hljs-number">4</span> <span class="hljs-operator">-</span> <span class="hljs-variable">a</span> 的值是 <span class="hljs-number">9</span><br>先运算后赋值：<br><span class="hljs-built_in">Line</span> <span class="hljs-number">5</span> <span class="hljs-operator">-</span> <span class="hljs-variable">c</span> 的值是 <span class="hljs-number">11</span><br><span class="hljs-built_in">Line</span> <span class="hljs-number">6</span> <span class="hljs-operator">-</span> <span class="hljs-variable">a</span> 的值是 <span class="hljs-number">11</span><br><span class="hljs-built_in">Line</span> <span class="hljs-number">7</span> <span class="hljs-operator">-</span> <span class="hljs-variable">c</span> 的值是 <span class="hljs-number">9</span><br><span class="hljs-built_in">Line</span> <span class="hljs-number">8</span> <span class="hljs-operator">-</span> <span class="hljs-variable">a</span> 的值是 <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表显示了 C 语言支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>检查两个操作数的值是否相等，如果相等则条件为真。</td><td>(A == B) 为假。</td></tr><tr><td>!=</td><td>检查两个操作数的值是否相等，如果不相等则条件为真。</td><td>(A != B) 为真。</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td>(A &gt; B) 为假。</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td>(A &lt; B) 为真。</td></tr><tr><td>&gt;=</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td>(A &gt;= B) 为假。</td></tr><tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td>(A &lt;= B) 为真。</td></tr></tbody></table><h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C 语言中所有可用的关系运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">21</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> c ;<br>    <span class="hljs-keyword">if</span>( a == b )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - a 等于 b\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - a 不等于 b\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( a &lt; b )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - a 小于 b\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - a 不小于 b\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( a &gt; b ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - a 大于 b\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - a 不大于 b\n&quot;</span> );<br>    &#125; <span class="hljs-comment">/* 改变 a 和 b 的值 */</span><br>    a = <span class="hljs-number">5</span>;<br>    b = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">if</span> ( a &lt;= b ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 4 - a 小于或等于 b\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( b &gt;= a ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 5 - b 大于或等于 a\n&quot;</span> );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">Line <span class="hljs-number">1</span> - <span class="hljs-selector-tag">a</span> 不等于 <span class="hljs-selector-tag">b</span><br>Line <span class="hljs-number">2</span> - <span class="hljs-selector-tag">a</span> 不小于 <span class="hljs-selector-tag">b</span><br>Line <span class="hljs-number">3</span> - <span class="hljs-selector-tag">a</span> 大于 <span class="hljs-selector-tag">b</span><br>Line <span class="hljs-number">4</span> - <span class="hljs-selector-tag">a</span> 小于或等于 <span class="hljs-selector-tag">b</span><br>Line <span class="hljs-number">5</span> - <span class="hljs-selector-tag">b</span> 大于或等于 <span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td>(A &amp;&amp; B) 为假。</td></tr><tr><td>||</td><td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td>(A || B) 为真。</td></tr><tr><td>!</td><td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td>!(A &amp;&amp; B) 为真。</td></tr></tbody></table><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C 语言中所有可用的逻辑运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> c ;<br>    <span class="hljs-keyword">if</span> ( a &amp;&amp; b )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - 条件为真\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( a || b )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - 条件为真\n&quot;</span> );<br>    &#125; <span class="hljs-comment">/* 改变 a 和 b 的值 */</span><br>    a = <span class="hljs-number">0</span>;<br>    b = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> ( a &amp;&amp; b )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - 条件为真\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - 条件为假\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( !(a &amp;&amp; b) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 4 - 条件为真\n&quot;</span> );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Line</span> <span class="hljs-number">1</span> - 条件为真<br><span class="hljs-attribute">Line</span> <span class="hljs-number">2</span> - 条件为真<br><span class="hljs-attribute">Line</span> <span class="hljs-number">3</span> - 条件为假<br><span class="hljs-attribute">Line</span> <span class="hljs-number">4</span> - 条件为真<br></code></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><table><thead><tr><th>p | q</th><th>p &amp; q</th><th>p</th><th>q</th><th>p ^ q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">A</span> <span class="hljs-operator">=</span> <span class="hljs-number">0011</span> <span class="hljs-number">1100</span><br><br><span class="hljs-attribute">B</span> <span class="hljs-operator">=</span> <span class="hljs-number">0000</span> <span class="hljs-number">1101</span><br></code></pre></td></tr></table></figure><p>-—————-</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-keyword">A</span>&amp;B = <span class="hljs-number">0000 1100</span><br><br><span class="hljs-keyword">A</span>|B = <span class="hljs-number">0011 1101</span><br><br><span class="hljs-keyword">A</span>^B = <span class="hljs-number">0011 0001</span><br><br>~<span class="hljs-keyword">A</span>  = <span class="hljs-number">1100 0011</span><br></code></pre></td></tr></table></figure><p>下表显示了 C 语言支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与操作，按二进制位进行”与”运算。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>|</td><td>按位或运算符，按二进制位进行”或”运算。</td><td>(A | B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>异或运算符，按二进制位进行”异或”运算。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>取反运算符，按二进制位进行”取反”运算。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C 语言中所有可用的位运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">60</span>; <span class="hljs-comment">/* 60 = 0011 1100 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b = <span class="hljs-number">13</span>; <span class="hljs-comment">/* 13 = 0000 1101 */</span><br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>    c = a &amp; b; <span class="hljs-comment">/* 12 = 0000 1100 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );<br>    c = a | b; <span class="hljs-comment">/* 61 = 0011 1101 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - c 的值是 %d\n&quot;</span>, c );<br>    c = a ^ b; <span class="hljs-comment">/* 49 = 0011 0001 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );<br>    c = ~a; <span class="hljs-comment">/*-61 = 1100 0011 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 4 - c 的值是 %d\n&quot;</span>, c );<br>    c = a &lt;&lt; <span class="hljs-number">2</span>; <span class="hljs-comment">/* 240 = 1111 0000 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );<br>    c = a &gt;&gt; <span class="hljs-number">2</span>; <span class="hljs-comment">/* 15 = 0000 1111 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 6 - c 的值是 %d\n&quot;</span>, c );<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">Line <span class="hljs-number">1</span> - c 的值是 <span class="hljs-number">12</span><br>Line <span class="hljs-number">2</span> - c 的值是 <span class="hljs-number">61</span><br>Line <span class="hljs-number">3</span> - c 的值是 <span class="hljs-number">49</span><br>Line <span class="hljs-number">4</span> - c 的值是 <span class="hljs-number">-61</span><br>Line <span class="hljs-number">5</span> - c 的值是 <span class="hljs-number">240</span><br>Line <span class="hljs-number">6</span> - c 的值是 <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下表列出了 C 语言支持的赋值运算符：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td>+=</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr><tr><td>-=</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr><tr><td>*=</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C *= A 相当于 C = C * A</td></tr><tr><td>/=</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr><tr><td>%=</td><td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td>C %= A 相当于 C = C % A</td></tr><tr><td>&lt;&lt;=</td><td>左移且赋值运算符</td><td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt;=</td><td>右移且赋值运算符</td><td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与且赋值运算符</td><td>C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td>^=</td><td>按位异或且赋值运算符</td><td>C ^= 2 等同于 C = C ^ 2</td></tr><tr><td>|=</td><td>按位或且赋值运算符</td><td>C |= 2 等同于 C = C | 2</td></tr></tbody></table><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C 语言中所有可用的赋值运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">21</span>;<br>    <span class="hljs-type">int</span> c ;<br>    c = a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - = 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c += a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - += 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c -= a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - -= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c *= a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 4 - *= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c /= a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 5 - /= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c = <span class="hljs-number">200</span>;<br>    c %= a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 6 - %%= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c &lt;&lt;= <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 7 - &lt;&lt;= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c &gt;&gt;= <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 8 - &gt;&gt;= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c &amp;= <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 9 - &amp;= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c ^= <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 10 - ^= 运算符实例，c 的值 = %d\n&quot;</span>, c );<br>    c |= <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 11 - |= 运算符实例，c 的值 = %d\n&quot;</span>, c ); <br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Line</span> <span class="hljs-number">1</span> - =  运算符实例，c 的值 = <span class="hljs-number">21</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">2</span> - += 运算符实例，c 的值 = <span class="hljs-number">42</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">3</span> - -= 运算符实例，c 的值 = <span class="hljs-number">21</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">4</span> - *= 运算符实例，c 的值 = <span class="hljs-number">441</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">5</span> - /= 运算符实例，c 的值 = <span class="hljs-number">21</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">6</span> - %= 运算符实例，c 的值 = <span class="hljs-number">11</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">7</span> - &lt;&lt;= 运算符实例，c 的值 = <span class="hljs-number">44</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">8</span> - &gt;&gt;= 运算符实例，c 的值 = <span class="hljs-number">11</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">9</span> - &amp;= 运算符实例，c 的值 = <span class="hljs-number">2</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">10</span> - ^= 运算符实例，c 的值 = <span class="hljs-number">0</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">11</span> - |= 运算符实例，c 的值 = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="杂项运算符-↦-sizeof-amp-三元"><a href="#杂项运算符-↦-sizeof-amp-三元" class="headerlink" title="杂项运算符 ↦ sizeof &amp; 三元"></a>杂项运算符 ↦ sizeof &amp; 三元</h2><p>下表列出了 C 语言支持的其他一些重要的运算符，包括 <strong>sizeof</strong> 和 **? :**。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>sizeof()</td><td>返回变量的大小。</td><td>sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td>&amp;</td><td>返回变量的地址。</td><td>&a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td>指向一个变量。</td><td>*a; 将指向一个变量。</td></tr><tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则值为 X : 否则值为 Y</td></tr></tbody></table><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C 语言中所有可用的杂项运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">short</span> b;<br>    <span class="hljs-type">double</span> c;<br>    <span class="hljs-type">int</span>* ptr;<br>    <span class="hljs-comment">/* sizeof 运算符实例 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - 变量 a 的大小 = %lu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a) );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - 变量 b 的大小 = %lu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(b) );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - 变量 c 的大小 = %lu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(c) );<br><br>    <span class="hljs-comment">/* &amp; 和 \* 运算符实例 */</span><br>    ptr = &amp;a;<span class="hljs-comment">/* &#x27;ptr&#x27; 现在包含 &#x27;a&#x27; 的地址 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值是 %d\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*ptr 是 %d\n&quot;</span>, *ptr);<br><br>    <span class="hljs-comment">/* 三元运算符实例 */</span><br>    a = <span class="hljs-number">10</span>;<br>    b = (a == <span class="hljs-number">1</span>) ? <span class="hljs-number">20</span>: <span class="hljs-number">30</span>;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;b 的值是 %d\n&quot;</span>, b );<br><br>    b = (a == <span class="hljs-number">10</span>) ? <span class="hljs-number">20</span>: <span class="hljs-number">30</span>;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;b 的值是 %d\n&quot;</span>, b );<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Line <span class="hljs-number">1</span> - 变量 <span class="hljs-selector-tag">a</span> 的大小 = <span class="hljs-number">4</span><br>Line <span class="hljs-number">2</span> - 变量 <span class="hljs-selector-tag">b</span> 的大小 = <span class="hljs-number">2</span><br>Line <span class="hljs-number">3</span> - 变量 c 的大小 = <span class="hljs-number">8</span><br><span class="hljs-selector-tag">a</span> 的值是 <span class="hljs-number">4</span><br>*ptr 是 <span class="hljs-number">4</span><br><span class="hljs-selector-tag">b</span> 的值是 <span class="hljs-number">30</span><br><span class="hljs-selector-tag">b</span> 的值是 <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="C-中的运算符优先级"><a href="#C-中的运算符优先级" class="headerlink" title="C 中的运算符优先级"></a>C 中的运算符优先级</h2><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p><p>例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p><table><thead><tr><th>类别</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ - -</td><td>从左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ - - (type)* &amp; sizeof</td><td>从右到左</td></tr><tr><td>乘除</td><td>* / %</td><td>从左到右</td></tr><tr><td>加减</td><td>+ -</td><td>从左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td>从左到右</td></tr><tr><td>关系</td><td>&lt; &lt;= &gt; &gt;=</td><td>从左到右</td></tr><tr><td>相等</td><td>== !=</td><td>从左到右</td></tr><tr><td>位与 AND</td><td>&amp;</td><td>从左到右</td></tr><tr><td>位异或 XOR</td><td>^</td><td>从左到右</td></tr><tr><td>位或 OR</td><td>|</td><td>从左到右</td></tr><tr><td>逻辑与 AND</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>逻辑或 OR</td><td>||</td><td>从左到右</td></tr><tr><td>条件</td><td>?:</td><td>从右到左</td></tr><tr><td>赋值</td><td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td><td>从右到左</td></tr><tr><td>逗号</td><td>,</td><td>从左到右</td></tr></tbody></table><h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C 语言中运算符的优先级：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">15</span>;<br>    <span class="hljs-type">int</span> d = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> e;<br>    e = (a + b) * c / d;    <span class="hljs-comment">// ( 30 \* 15 ) / 5</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(a + b) * c / d 的值是 %d\n&quot;</span>, e );<br>    e = ((a + b) * c) / d; <span class="hljs-comment">// (30 \* 15 ) / 5</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;((a + b) * c) / d 的值是 %d\n&quot;</span> , e );<br>    e = (a + b) * (c / d); <span class="hljs-comment">// (30) \* (15/5)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(a + b) * (c / d) 的值是 %d\n&quot;</span>, e );<br>    e = a + (b * c) / d; <span class="hljs-comment">// 20 + (150/5)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a + (b * c) / d 的值是 %d\n&quot;</span> , e );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">(a + b) * c / d 的值是 <span class="hljs-number">90</span><br>((a + b) * c) / d 的值是 <span class="hljs-number">90</span><br>(a + b) * (c / d) 的值是 <span class="hljs-number">90</span><br>a + (b * c) / d 的值是 <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C 判断"></a>C 判断</h1><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p><p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。</p><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td><a href="./#if-%E8%AF%AD%E5%8F%A5" title="C 中的 if 语句">if 语句</a></td><td>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td></tr><tr><td><a href="./#if%E2%80%A6else-%E8%AF%AD%E5%8F%A5" title="C 中的 if...else 语句">if…else 语句</a></td><td>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td></tr><tr><td><a href="./#%E5%B5%8C%E5%A5%97-if-%E8%AF%AD%E5%8F%A5" title="C 中的嵌套 if 语句">嵌套 if 语句</a></td><td>您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr><tr><td><a href="./#switch-%E8%AF%AD%E5%8F%A5" title="C 中的 switch 语句">switch 语句</a></td><td>一个 <code>switch</code> 语句允许测试一个变量等于多个值时的情况。</td></tr><tr><td><a href="./#%E5%B5%8C%E5%A5%97-switch-%E8%AF%AD%E5%8F%A5" title="C 中的嵌套 switch 语句">嵌套 switch 语句</a></td><td>您可以在一个 <code>switch</code> 语句内使用另一个 <code>switch</code> 语句。</td></tr></tbody></table><h2 id="运算符-三元运算符"><a href="#运算符-三元运算符" class="headerlink" title="? : 运算符(三元运算符)"></a>? : 运算符(三元运算符)</h2><p>我们已经在前面的章节中讲解了 **条件运算符 ? :**，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">Exp1 ? Exp2 : Exp3;<br></code></pre></td></tr></table></figure><p>其中，<code>Exp1</code>、<code>Exp2</code> 和 <code>Exp3</code> 是表达式。请注意，冒号的使用和位置。</p><p>? 表达式的值是由 <code>Exp1</code> 决定的。如果 <code>Exp1</code> 为真，则计算 <code>Exp2</code> 的值，结果即为整个表达式的值。如果 <code>Exp1</code> 为假，则计算 <code>Exp3</code> 的值，结果即为整个表达式的值。</p><p><img src="https://blog.yoobit.cn/img_out/C_LEARN/Conditional-Statement-in-C-Programming-Lanuage-Ternary-Operator.png"></p><h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过输入一个数字来判断它是否为奇数或偶数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入一个数字 : &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br><br>    (num%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)?<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;偶数&quot;</span>):<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;奇数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>C 语言中 <strong>if</strong> 语句的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(boolean_expression)<br>&#123;<br>   <span class="hljs-comment">/* 如果布尔表达式为真将执行的语句 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果布尔表达式为 <strong>true</strong>，则 if 语句内的代码块将被执行。如果布尔表达式为 <strong>false</strong>，则 if 语句结束后的第一组代码（闭括号后）将被执行。</p><p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。</p><h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;   <span class="hljs-comment">/* 局部变量定义 */</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">/* 使用 if 语句检查布尔条件 */</span><br>    <span class="hljs-keyword">if</span>( a &lt; <span class="hljs-number">20</span> )<br>    &#123; <span class="hljs-comment">/* 如果条件为真，则输出下面的语句 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 小于 20\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值是 %d\n&quot;</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> 小于 <span class="hljs-number">20</span><br><span class="hljs-attribute">a</span> 的值是 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h2><p>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为 false 时执行。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>C 语言中 <strong>if…else</strong> 语句的语法：</p><p>if(boolean_expression)<br>{<br>   /* 如果布尔表达式为真将执行的语句 <em>/<br>}<br>else<br>{<br>   /</em> 如果布尔表达式为假将执行的语句 */<br>}</p><p>如果布尔表达式为 <strong>true</strong>，则执行 <strong>if</strong> 块内的代码。如果布尔表达式为 <strong>false</strong>，则执行 <strong>else</strong> 块内的代码。</p><p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。</p><h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* 局部变量定义 */</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>; <span class="hljs-comment">/* 检查布尔条件 */</span><br>    <span class="hljs-keyword">if</span>( a &lt; <span class="hljs-number">20</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 如果条件为真，则输出下面的语句 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 小于 20\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 如果条件为假，则输出下面的语句 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 大于 20\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值是 %d\n&quot;</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> 大于 <span class="hljs-number">20</span><br><span class="hljs-attribute">a</span> 的值是 <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><p>一个 <strong>if</strong> 语句后可跟一个可选的 <strong>else if…else</strong> 语句，这可用于测试多种条件。</p><p>当使用 <code>if...else if...else</code> 语句时，以下几点需要注意：</p><ul><li>  一个 if 后可跟零个或一个 <code>else</code>，<code>else</code> 必须在所有 <code>else if</code> 之后。</li><li>  一个 if 后可跟零个或多个 <code>else if</code>，<code>else if</code> 必须在 <code>else</code> 之前。</li><li>  一旦某个 <code>else if</code> 匹配成功，其他的 <code>else if</code> 或 <code>else</code> 将不会被测试。</li></ul><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>C 语言中的 <strong>if…else if…else</strong> 语句的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(boolean_expression <span class="hljs-number">1</span>)<br>&#123;<br>   <span class="hljs-comment">/* 当布尔表达式 1 为真时执行 */</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( boolean_expression <span class="hljs-number">2</span>)<br>&#123;<br>   <span class="hljs-comment">/* 当布尔表达式 2 为真时执行 */</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( boolean_expression <span class="hljs-number">3</span>)<br>&#123;<br>   <span class="hljs-comment">/* 当布尔表达式 3 为真时执行 */</span><br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>   <span class="hljs-comment">/* 当上面条件都不为真时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* 局部变量定义 */</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">/* 检查布尔条件 */</span><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 如果 if 条件为真，则输出下面的语句 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值是 10\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">20</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 如果 else if 条件为真，则输出下面的语句 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值是 20\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">30</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 如果 else if 条件为真，则输出下面的语句 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值是 30\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 如果上面条件都不为真，则输出下面的语句 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没有匹配的值\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的准确值是 %d\n&quot;</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">没有匹配的值<br>a 的准确值是 <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="嵌套-if-语句"><a href="#嵌套-if-语句" class="headerlink" title="嵌套 if 语句"></a>嵌套 if 语句</h2><p>在 C 语言中，<strong>嵌套</strong> if-else 语句是合法的，这意味着您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>C 语言中 <strong>嵌套 if</strong> 语句的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>( boolean_expression <span class="hljs-number">1</span>)<br>&#123;<br>   <span class="hljs-comment">/* 当布尔表达式 1 为真时执行 */</span><br>   <span class="hljs-keyword">if</span>(boolean_expression <span class="hljs-number">2</span>)<br>   &#123;<br>      <span class="hljs-comment">/* 当布尔表达式 2 为真时执行 */</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以嵌套 <code>else if...else</code>，方式与嵌套 <code>if</code> 语句相似。</p><h3 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* 局部变量定义 */</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;<br>    <span class="hljs-comment">/* 检查布尔条件 */</span><br>    <span class="hljs-keyword">if</span>( a == <span class="hljs-number">100</span> ) &#123;<br>        <span class="hljs-comment">/* 如果条件为真，则检查下面的条件 */</span><br>        <span class="hljs-keyword">if</span>( b == <span class="hljs-number">200</span> ) &#123;<br>            <span class="hljs-comment">/* 如果条件为真，则输出下面的语句 */</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值是 100，且 b 的值是 200\n&quot;</span> );<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的准确值是 %d\n&quot;</span>, a );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b 的准确值是 %d\n&quot;</span>, b );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> 的值是 <span class="hljs-number">100</span>，且 b 的值是 <span class="hljs-number">200</span><br><span class="hljs-attribute">a</span> 的准确值是 <span class="hljs-number">100</span><br><span class="hljs-attribute">b</span> 的准确值是 <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>一个 <code>switch</code> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 <code>case</code>，且被测试的变量会对每个 <code>switch case</code> 进行检查。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>C 语言中 <code>switch</code> 语句的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">switch</span>(expression)<br>&#123;<br>    <span class="hljs-keyword">case</span> constant-expression :<br>        statement(s); <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 可选的 */</span><br>    <span class="hljs-keyword">case</span> constant-expression :<br>        statement(s); <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 可选的 */</span><br>    <span class="hljs-comment">/* 您可以有任意数量的 case 语句 */</span><br>    <span class="hljs-keyword">default</span> :<br>        <span class="hljs-comment">/* 可选的 */</span><br>        statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>switch</code> 语句必须遵循下面的规则：</p><ul><li>  <code>switch</code> 语句中的 <code>expression</code> 是一个常量表达式，必须是一个整型或枚举类型。</li><li>  在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li><li>  case 的 <code>constant-expression</code> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li><li>  当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <code>break</code> 语句为止。</li><li>  当遇到 <code>break</code> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li><li>  不是每一个 case 都需要包含 <code>break</code>。如果 case 语句不包含 <code>break</code>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li><li>  一个 <code>switch</code> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <code>break</code> 语句不是必需的。</li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://blog.yoobit.cn/img_out/C_LEARN/switch_statement.jpg" alt="C 中的 switch 语句"></p><h3 id="实例-19"><a href="#实例-19" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* 局部变量定义 */</span><br>    <span class="hljs-type">char</span> grade = <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">switch</span>(grade)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span> :<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;很棒！\n&quot;</span> ); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span> :<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span> :<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;做得好\n&quot;</span> ); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span> :<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;您通过了\n&quot;</span> ); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;F&#x27;</span> :<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最好再试一下\n&quot;</span> ); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span> :<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无效的成绩\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;您的成绩是 %c\n&quot;</span>, grade );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">做得好<br>您的成绩是 B<br></code></pre></td></tr></table></figure><h2 id="嵌套-switch-语句"><a href="#嵌套-switch-语句" class="headerlink" title="嵌套 switch 语句"></a>嵌套 switch 语句</h2><p>您可以把一个 <code>switch</code> 作为一个外部 <code>switch</code> 的语句序列的一部分，即可以在一个 <code>switch</code> 语句内使用另一个 <code>switch</code> 语句。即使内部和外部 <code>switch</code> 的 <code>case</code> 常量包含共同的值，也没有矛盾。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>C 语言中 <strong>嵌套 switch</strong> 语句的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">switch</span>(ch1) &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这个 A 是外部 switch 的一部分&quot;</span> );<br>      <span class="hljs-keyword">switch</span>(ch2) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这个 A 是内部 switch 的一部分&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-comment">/* 内部 B case 代码 */</span><br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-comment">/* 外部 B case 代码 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例-20"><a href="#实例-20" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* 局部变量定义 */</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">switch</span>(a) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这是外部 switch 的一部分\n&quot;</span>);<br>            <span class="hljs-keyword">switch</span>(b) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">200</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这是内部 switch 的一部分\n&quot;</span>);<br>                &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的准确值是 %d\n&quot;</span>, a );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b 的准确值是 %d\n&quot;</span>, b );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">这是外部 <span class="hljs-keyword">switch</span> 的一部分<br>这是内部 <span class="hljs-keyword">switch</span> 的一部分<br>a 的准确值是 <span class="hljs-number">100</span><br>b 的准确值是 <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h1 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h1><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><p>C 库函数 <code>int printf(const char *format, ...)</code> 发送格式化输出到标准输出 <code>stdout</code>。</p><p>printf()函数的调用格式为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;格式化字符串&gt;&quot;</span>, &lt;参量表&gt;);<br></code></pre></td></tr></table></figure><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>下面是 printf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>  <code>format</code> – 这是字符串，包含了要被写入到标准输出 <code>stdout</code> 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 <strong>%[flags][width][.precision][length]specifier</strong>，具体讲解如下：</li></ul><table><thead><tr><th>格式字符</th><th>意义</th></tr></thead><tbody><tr><td>a, A</td><td>以十六进制形式输出浮点数(C99 新增)。实例 printf(“pi=%a\n”, 3.14); 输出 <strong>pi=0x1.91eb86p+1</strong>。</td></tr><tr><td>d</td><td>以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td>o</td><td>以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td>x,X</td><td>以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td>u</td><td>以十进制形式输出无符号整数</td></tr><tr><td>f</td><td>以小数形式输出单、双精度实数</td></tr><tr><td>e,E</td><td>以指数形式输出单、双精度实数</td></tr><tr><td>g,G</td><td>以%f或%e中较短的输出宽度输出单、双精度实数</td></tr><tr><td>c</td><td>输出单个字符</td></tr><tr><td>s</td><td>输出字符串</td></tr><tr><td>p</td><td>输出指针地址</td></tr><tr><td>lu</td><td>32位无符号整数</td></tr><tr><td>llu</td><td>64位无符号整数</td></tr></tbody></table><table><thead><tr><th>flags（标识）</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。</td></tr><tr><td>+</td><td>强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td>空格</td><td>如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td>#</td><td>与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。</td></tr><tr><td>与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。  与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。</td><td></td></tr><tr><td>0</td><td>在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。</td></tr></tbody></table><table><thead><tr><th>width（宽度）</th><th>描述</th></tr></thead><tbody><tr><td>(number)</td><td>要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。</td></tr><tr><td>*</td><td>宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table><table><thead><tr><th>.precision（精度）</th><th>描述</th></tr></thead><tbody><tr><td>.number</td><td>对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。对于 e、E 和 f 说明符：要在小数点后输出的小数位数。  对于 g 和 G 说明符：要输出的最大有效位数。  对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。  对于 c 类型：没有任何影响。  当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。</td></tr><tr><td>.*</td><td>精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table><p>`</p><table><thead><tr><th>length（长度）</th><th>描述</th></tr></thead><tbody><tr><td>h</td><td>参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td>l</td><td>参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td>L</td><td>参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</td></tr></tbody></table><ul><li><strong>附加参数</strong> – 根据不同的 <code>format</code> 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 <code>format</code> 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p><h3 id="实例1-1"><a href="#实例1-1" class="headerlink" title="实例1"></a>实例1</h3><p>下面的实例演示了 printf() 函数的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> ch;<br>    <span class="hljs-keyword">for</span>( ch = <span class="hljs-number">75</span> ; ch &lt;= <span class="hljs-number">100</span>; ch++ )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ASCII 值 = %d, 字符 = %c\n&quot;</span>, ch , ch );<br>    &#125;<br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C">ASCII 值 = <span class="hljs-number">75</span>, 字符 = K<br>ASCII 值 = <span class="hljs-number">76</span>, 字符 = L<br>ASCII 值 = <span class="hljs-number">77</span>, 字符 = M<br>ASCII 值 = <span class="hljs-number">78</span>, 字符 = N<br>ASCII 值 = <span class="hljs-number">79</span>, 字符 = O<br>ASCII 值 = <span class="hljs-number">80</span>, 字符 = P<br>ASCII 值 = <span class="hljs-number">81</span>, 字符 = Q<br>ASCII 值 = <span class="hljs-number">82</span>, 字符 = R<br>ASCII 值 = <span class="hljs-number">83</span>, 字符 = S<br>ASCII 值 = <span class="hljs-number">84</span>, 字符 = T<br>ASCII 值 = <span class="hljs-number">85</span>, 字符 = U<br>ASCII 值 = <span class="hljs-number">86</span>, 字符 = V<br>ASCII 值 = <span class="hljs-number">87</span>, 字符 = W<br>ASCII 值 = <span class="hljs-number">88</span>, 字符 = X<br>ASCII 值 = <span class="hljs-number">89</span>, 字符 = Y<br>ASCII 值 = <span class="hljs-number">90</span>, 字符 = Z<br>ASCII 值 = <span class="hljs-number">91</span>, 字符 = \[<br>ASCII 值 = <span class="hljs-number">92</span>, 字符 = \\<br>ASCII 值 = <span class="hljs-number">93</span>, 字符 = \]<br>ASCII 值 = <span class="hljs-number">94</span>, 字符 = ^<br>ASCII 值 = <span class="hljs-number">95</span>, 字符 = \_<br>ASCII 值 = <span class="hljs-number">96</span>, 字符 = \`<br>ASCII 值 = <span class="hljs-number">97</span>, 字符 = a<br>ASCII 值 = <span class="hljs-number">98</span>, 字符 = b<br>ASCII 值 = <span class="hljs-number">99</span>, 字符 = c<br>ASCII 值 = <span class="hljs-number">100</span>, 字符 = d<br></code></pre></td></tr></table></figure><p>以下实例输出各种格式化数据：</p><h3 id="实例2-1"><a href="#实例2-1" class="headerlink" title="实例2"></a>实例2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;blog.yoobit.cn&quot;</span>;<br>    <span class="hljs-type">float</span> flt = <span class="hljs-number">10.234</span>;<br>    <span class="hljs-type">int</span> no = <span class="hljs-number">150</span>;<br>    <span class="hljs-type">double</span> dbl = <span class="hljs-number">20.123456</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符为 %c \n&quot;</span>, ch);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串为 %s \n&quot;</span> , str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;浮点数为 %f \n&quot;</span>, flt);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;整数为 %d\n&quot;</span> , no);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;双精度值为 %lf \n&quot;</span>, dbl);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;八进制值为 %o \n&quot;</span>, no);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;十六进制值为 %x \n&quot;</span>, no);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>执行输出结果为：<br>```C<br>字符为 A<br>字符串为 blog.yoobit.cn<br>浮点数为 <span class="hljs-number">10.234000</span><br>整数为 <span class="hljs-number">150</span><br>双精度值为 <span class="hljs-number">20.123456</span><br>八进制值为 <span class="hljs-number">226</span><br>十六进制值为 <span class="hljs-number">96</span><br></code></pre></td></tr></table></figure><h3 id="规定符"><a href="#规定符" class="headerlink" title="规定符"></a>规定符</h3><ul><li>  <strong>%d</strong> 十进制有符号整数</li><li>  <strong>%u</strong> 十进制无符号整数</li><li>  <strong>%f</strong> 浮点数</li><li>  <strong>%s</strong> 字符串</li><li>  <strong>%c</strong> 单个字符</li><li>  <strong>%p</strong> 指针的值</li><li>  <strong>%e</strong> 指数形式的浮点数</li><li>  <strong>%x, %X</strong> 无符号以十六进制表示的整数</li><li>  <strong>%o</strong> 无符号以八进制表示的整数</li><li>  <strong>%g</strong> 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</li><li>  <strong>%p</strong> 输出地址符</li><li>  <strong>%lu</strong> 32位无符号整数</li><li>  <strong>%llu</strong> 64位无符号整数</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档</tag>
      
      <tag>基础</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4 网络层"></a>4 网络层</h1><p>重点内容：</p><ol><li>虚拟互联网络和两种服务、两个层面的概念。</li><li>IP地址与MAC地址的关系。</li><li>传统分类的IP地址和无分类域间路由选择CIDR（后者是重点）。</li><li>路由选择协议的工作原理。</li></ol><h2 id="4-1-网络层的几个重要概念"><a href="#4-1-网络层的几个重要概念" class="headerlink" title="4.1 网络层的几个重要概念"></a>4.1 网络层的几个重要概念</h2><h3 id="4-1-1-网络层提供的服务"><a href="#4-1-1-网络层提供的服务" class="headerlink" title="4.1.1 网络层提供的服务"></a>4.1.1 网络层提供的服务</h3><p>针对计算机通信的可靠性交付，是网络还是端系统进行负责提出了两类方案：</p><ol><li><p>建立连接（在分组交换中是建立一条<em><strong>虚电路VC</strong></em>(Virtual Circuit)，双方沿虚电路发送分组。不需要填写完整目的主机地址，只需要填写虚电路编号）。这种通信再使用可靠网络协议传输，可达到：按序、不丢失、不重复。通信结束后释放建立的虚电路。</p></li><li><p>互联网采用的设计思路：<em><strong>网络层，其向上层只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong></em>。数据报（或IP数据报）就是“分组”。</p><p> <em><strong>网络层不提供服务质量的承诺</strong></em>，可能会出现出错、丢失、重复、失序等问题。可靠通信交由运输层负责（包括差错处理、流量控制等）。</p><p> 优点：网络造价大大降低、运行方式灵活，能够适应多种应用。</p></li></ol><p><img src="https://blog.yoobit.cn/img_out/net/net_4_1.png" alt="网络层提供的两种服务" title="网络层提供的两种服务"></p><p>虚电路服务与数据报服务的主要区别：</p><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信应由网络来保证</td><td>可靠通信应由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址，即IP地址</td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立查找转发表进行转发</td></tr><tr><td>当节点出故障时</td><td>所有通过出故障的节点的虚电路均不能工作</td><td>出故障的节点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点的顺序不一定按发送的顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h3 id="4-1-2-网络层的两个层面"><a href="#4-1-2-网络层的两个层面" class="headerlink" title="4.1.2 网络层的两个层面"></a>4.1.2 网络层的两个层面</h3><p>转发表由路由表导出，路由表由互联网中许多路由器，按共同选定的路由选择协议，通过许多次相互交换路由信息而产生的。</p><p>路由器之间传送的信息有以下两大类：</p><ul><li>转发源主机和目标主机之间所传送的数据</li><li>传送路由信息。目的是为了在路由器中创建路由表，并由此导出为转发分组而用的转发表。</li></ul><p><img src="https://blog.yoobit.cn/img_out/net/net_4_2.png" alt="网络层的数据层面和控制层面" title="网络层的数据层面和控制层面"></p><p>网络层抽象划分为<em><strong>数据层面</strong></em>（或<em><strong>转发层面</strong></em>）和<em><strong>控制层面</strong></em></p><blockquote><p>数据层面中：每一个路由器根据本路由器生成的转发表，把收到的分组从查找到的相应接口转发出去。采用硬件转发速度非常快。</p></blockquote><blockquote><p>控制层面中：路由器必须与相邻的路由器经常交换路由信息，才能创建出本路由器的路由表。需要使用软件速度会慢很多。</p></blockquote><p>数据层面是<em><strong>独立</strong></em>地转发分组，而控制层面需要许多路由器<em><strong>协同动作</strong></em>。</p><p>新技术：<em><strong>软件定义网络SDN</strong></em>（Softwware Defined Network）<br><img src="https://blog.yoobit.cn/img_out/net/net_4_2.png" alt="软件定义网络SDN中的控制层面和数据层面" title="软件定义网络SDN中的控制层面和数据层面"><br>在SDN结构中，路由选择软件不存在了，因此路由器之间不再相互交换路由信息。在网络控制层面上由逻辑上集中的<em><strong>远程控制器</strong></em>（物理上可以由不同地点多个服务器组成），负责掌握各主机和整个网络的状态，并为每个分组计算最佳路由，在每个路由器中生成正确转发表。路由器仅需收到分组、查找转发表、转发分组即可。</p><p>像大型专用数据中心之间的广域网，使用SDN模式建造可以使网络运行效率提高，同时获得更好的经济效益。</p><h2 id="4-2-网络协议IP"><a href="#4-2-网络协议IP" class="headerlink" title="4.2 网络协议IP"></a>4.2 网络协议IP</h2><p><em><strong>网络协议IP</strong></em>（Internet Protocol）<br>与协议IP配套使用的还有三个协议：</p><ul><li><em><strong>地址解析协议 ARP</strong></em>(Address Resolution Protocol)</li><li><em><strong>网络控制报文协议 ICMP</strong></em>(Internet Control Message Protocol)</li><li><em><strong>网际组管理协议 IGMP</strong></em>(Internet Group Management Protocol)</li></ul><p><img src="https://blog.yoobit.cn/img_out/net/net_4_4.png" alt="网络协议IP及其配套协议" title="网络协议IP及其配套协议"></p><h3 id="4-2-1-虚拟互联网络"><a href="#4-2-1-虚拟互联网络" class="headerlink" title="4.2.1 虚拟互联网络"></a>4.2.1 虚拟互联网络</h3><p>将网络互相连接起来需要一些中间设备：</p><ol><li>物理层使用的中间设备叫做<em><strong>转发器</strong></em>(repeater)。</li><li>数据链路层使用的中间设备叫做<em><strong>网桥</strong></em>或<em><strong>桥接器</strong></em>(bridge)，以及<em><strong>交换机</strong></em>(switch)。</li><li>网络层使用的中间设备叫做<em><strong>路由器</strong></em>(router)。</li><li>在网络层以上使用的设备叫做<em><strong>网关</strong></em>(gateway)。</li></ol><p><img src="https://blog.yoobit.cn/img_out/net/net_4_5.png" alt="IP网的概念" title="IP网的概念"></p><p>如图4-5许多计算机网络通过一些路由器进行互联。因都使用相同的<em><strong>网际协议IP</strong></em>，因此可以把互联后的计算机网络看成一个<em><strong>虚拟互联网络</strong></em>(internet)。虚拟互联也就是逻辑互联，<em><strong>在网络层看起来好像是一个统一的网络</strong></em>。</p><p>使用协议IP的虚拟互联网络简称为<em><strong>IP网</strong></em>（IP网是虚拟的，但不必每次都强调“虚拟”二字）。</p><p><em><strong>使用IP网的好处是</strong></em>：当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编址方式、路由选择协议等）。</p><p>如果在这种覆盖全球的IP网的上层使用TCP协议，那么就是现在的互联网(Internet)。</p><p>当很多异构网络通过路由器互连，同时所有网络均使用相同的协议IP，那么在网络层讨论问题就显得很方便：</p><p>eg：分组从源节点A发送到目的节点B，若中间必须经过一个或几个路由器（这表明A和B不在同一个网络上），则是间接交付。若不需要经过路由器（这表示A和B在同一个网络上），则是直接交付。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_6.png" alt="分组在互联网中的传送" title="分组在互联网中的传送"></p><p><em><strong>互联网可以由多种异构网络互联组成</strong></em>（卫星链路、无线局域网、等等）</p><p>简化IP数据报就在网络层中传送，省略路由器之间的网络与连接在这些网络上的无关主机：</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_7.png" alt="源主机H1向目的主机H2发送分组" title="源主机H1向目的主机H2发送分组"></p><p>分组在传送途中的每一次转发都称为一“<em><strong>跳</strong></em>(hop)”，在路由器转发分组时也常常使用“<em><strong>下一跳</strong></em>(next hop)”的说法。上述例子中，前5跳都是间接交付，只有最后一跳是直接交付。</p><h3 id="4-2-2-IP地址"><a href="#4-2-2-IP地址" class="headerlink" title="4.2.2 IP地址"></a>4.2.2 IP地址</h3><h4 id="1-IP地址及其表示方法"><a href="#1-IP地址及其表示方法" class="headerlink" title="1. IP地址及其表示方法"></a>1. IP地址及其表示方法</h4><p>IP地址是给连接到互联网上的每一台主机或路由器的<em><strong>每一个接口</strong></em>，分配一个全世界范围内是唯一的32位的标识符。IP地址的结构可以使我们在互联网上很方便进行寻址。IP地址由<em><strong>互联网名字和数字分配机构ICANN</strong></em>进行分配。</p><p>IP地址<em><strong>点分十进制记法</strong></em><br><img src="https://blog.yoobit.cn/img_out/net/net_4_8.png" alt="采用点分十进制记法能够提高可读性" title="采用点分十进制记法能够提高可读性"></p><p>32位的IP地址采用两级结构，由两个字段组成。第一个字段是<em><strong>网络号</strong></em>，标志主机或路由器所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是<em><strong>主机号</strong></em>，它标志该主机（路由器）。一个主机号在所连接的网络（即网络号指明的网络中）中必须是唯一的。</p><p>由此可见，一个IP地址在整个互联网范围内是唯一的。</p><p>IP地址可以记为：</p><pre><code class="hljs">IP地址 ::=&#123;&lt;网络号&gt;,&lt;主机号&gt;&#125;</code></pre><p>“::=”表示“<em><strong>定义为</strong></em>”<br><img src="https://blog.yoobit.cn/img_out/net/net_4_9.png" alt="IP地址中的网络号和主机号字段" title="IP地址中的网络号和主机号字段"></p><p>当我们看到一个IP地址时，怎么知道它的网络号的位数n是多少？</p><h4 id="2-分类的IP地址"><a href="#2-分类的IP地址" class="headerlink" title="2.分类的IP地址"></a>2.分类的IP地址</h4><p><img src="https://blog.yoobit.cn/img_out/net/net_4_10.png" alt="分类的IP地址及各类地址所占的比例" title="分类的IP地址及各类地址所占的比例"></p><p>例如：10000000 00001110 00100011 00000111 这是一个B类地址，前16位是网络号，后16位是主机号</p><table><thead><tr><th>网络号</th><th>主机号</th><th>源地址使用</th><th>目的地址使用</th><th>代表的意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上的本主机</td></tr><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上主机号为X的主机</td></tr><tr><td>全1</td><td>全1</td><td>不可</td><td>可以</td><td>只在本网络上进行广播（各路由器军部转发）</td></tr><tr><td>Y</td><td>全1</td><td>不可</td><td>可以</td><td>对网络号为Y的网络上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0或全1的任何数</td><td>可以</td><td>可以</td><td>用于本地软件环回测试</td></tr></tbody></table><p>由于今年已经广泛使用无分类的IP地址进行路由选择，A、B、C类这种分类地址已经称为历史。</p><h4 id="3-无分类编址CIDR"><a href="#3-无分类编址CIDR" class="headerlink" title="3.无分类编址CIDR"></a>3.无分类编址CIDR</h4><p>全名：<em><strong>无分类域间路由选择CIDR</strong></em>(Classless Inter-Domain Routing,CIDR的读音是“sider”)。</p><p>要点有以下三个</p><p>(1)<em><strong>网络前缀</strong></em><br>CIDR将图4-9中的网络号改称为“<em><strong>网络前缀</strong></em>”(network-perfix)（或简称为“前缀”），用来指明网络。后面是主机号，用来指明主机，有时称为后缀(suffix)。</p><p>CIDR的记法是：</p><pre><code class="hljs">IP地址 ::=&#123;&lt;网络前缀&gt;,&lt;主机号&gt;&#125;</code></pre><p>这里区别最大是网络前缀的位数n不是固定的数，而是可以在0~32之间选取任意的值。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_11.png" alt="CIDR表示的IP地址" title="CIDR表示的IP地址"></p><p>CIDR采用<em><strong>斜线记法</strong></em>，或称CIDR记法，即在IP地址后加上斜线“/”，斜线后面就是网络前缀所占位数。</p><p>e.g. 128.14.35.7/20 二进制IP地址前20位是网络前缀，后12位是主机号</p><p>(2)<em><strong>地址块</strong></em></p><p>CIDR把网络前缀都相同的所有连续的IP地址组成一个“CIDR地址块”。一个CIDR地址块包含的IP地址的数据取决于网络前缀的位数。</p><p>我们只要知道任何一个地址，就知道这个地址块的起始地址和最大地址，以及地址块中的地址数。</p><p>e.g. 128.14.35.7/20 写成2进制形式，前20位是网络前缀，后12位是主机号</p><blockquote><p>128.14.35.7/20=<em><strong>10000000 00001110 0010</strong></em>0011 00000111</p></blockquote><p>可以得出最小地址和最大地址：</p><table align="center">    <tr>        <td align="center" style="font-weight:700">最小地址</td>        <td align="center">128.14.32.0</td>        <td align="center">10000000 00001110 00100000 00000000</td>    </tr>    <tr>        <td align="center" style="font-weight:700">最大地址</td>        <td align="center">128.14.47.255</td>        <td align="center">10000000 00001110 001011111 11111111</td>    </tr></table><p>这个地址块的IP地址共有$2^{12}$个，扣除主机号全0和全1的地址（最小地址和最大地址），可指派地址数是$2^{12}-2$个。我们常用最小地址和网络前缀的位数指明一个地址块。</p><p>显然最小地址并不是该地址块的网络地址。</p><p>也可用二进制代码简要地表示此地址块：100000000 00001110 0010<em>。<br>这里</em>代表主机号字段的所有的0。星号前的二进制代码的个数，就是网络前缀的位数。</p><p>在不需要指明网络地址时，也可以把这样的地址块简称为“/20地址块”</p><p>注意：</p><blockquote><p>128.14.32.7是IP地址，但未指明网络前缀长度，因此不知道网络地址是什么。<br>128.14.32.7/20 也是IP地址，同时指明网络前缀20位，因此可导出网络地址。<br>128.14.32.0/20 是包含多个IP地址的<em><strong>地址块</strong></em>或<em><strong>网络前缀</strong></em>，同时也是这个地址块中主机号全为0的地址。最后的0有时可以省略，简写为：128.14.32/20 。</p></blockquote><p>采用CIDR后，仅从斜线左边的IP地址已经无法知道其网络地址了。</p><p>(3)地址掩码</p><p>计算机看不见斜线记法，而是使用二进制来进行各种计算时就必须使用32为的地址掩码(address mask)从而能够从IP地址迅速算出网络地址。</p><p>地址掩码（常简称为掩码）由一连串1和接着一连串0组成，而1的个数就是网络前缀的长度。</p><p>地址掩码又称<em><strong>子网掩码</strong></em>。在CIDR记法中，斜线后面的数字就是地址掩码中1的个数。e.g. /20地址块的地址掩码是:11111111 11111111 11110000 00000000。这个掩码用CIDR记法表示就是255.255.240.0/20</p><p>将二进制IP地址和地址掩码进行<em><strong>按位AND</strong></em>运算，即可得出网络地址。</p><p>AND运算就是逻辑乘法运算，即：1 AND 1 = 1, 1 AND 0 = 0, 0 AND 0 = 0 。</p><p>e.g. IP地址是128.14.35.7/20<br><img src="https://blog.yoobit.cn/img_out/net/net_4_12.png" alt="从IP地址算出网络地址" title="从IP地址算出网络地址"></p><p>从上面运算得到： IP地址127.14.35.7/20 所在的网络地址是 127.14.32.0/20</p><p>CIDR地址中有三个特殊地址块：</p><ol><li>前缀n=32，即32为IP地址都是前缀，没有主机号。这个特殊地址用于主机路由。（见4.3.2）</li><li>前缀n=31，这个地址块只有两个IP地址，主机号分别为0和1。用于<em><strong>点对点链路</strong></em>（见后面第4小节）</li><li>前缀n=0，同时IP地址也是全0，即0.0.0.0/0 。这用于默认路由（见4.3.2节</li></ol><p>CIDR有一个好处就是可以更有效分配IP地址空间。</p><p>一个大的CIDR地址块中往往包含很多小地址块，所以在路由器的转发表中就利用较大的一个CIDR地址块来代替许多小的地址块，这种方法称为<em><strong>路由聚合</strong></em>。在从大的地址块找到小的地址块，再找到最终IP地址。大大压缩了转发表所占空间，减少了查找转发表所需时间。</p><p>例：<br><img src="https://blog.yoobit.cn/img_out/net/net_4_13.png" alt="CIDR地址块划分举例" title="CIDR地址块划分举例"></p><p>ISP拥有地址块206.0.64.0/18。某大学需要800IP地址，ISP分配一个地址块206.0.64.0/22，包括1024（即$2^{10}$）个地址，占该ISP拥有的地址空间的1/16。</p><p>ISP拥有地址块：<br><em><strong>11001110 00000000 01</strong></em>000100 00000000</p><p>大学拥有地址块：<br><em><strong>11001110 00000000 010001</strong></em>00 00000000<br>可清晰看出大学可分配$2^{10}$个地址</p><p>一系拥有的地址块：<br><em><strong>11001110 00000000 0100010</strong></em>0 00000000</p><p>二系拥有的地址块：<br><em><strong>11001110 00000000 01000110</strong></em> 00000000</p><p>三系拥有的地址块：<br><em><strong>11001110 00000000 01000111 0</strong></em>0000000</p><p>四系拥有的地址块：<br><em><strong>11001110 00000000 01000111 1</strong></em>0000000</p><p>采用地址聚合后，在转发表中只需要用一行来指出到206.0.64.0/18地址块的下一跳即可。</p><p>假设大学共4个系，在ISP内的路由器的转发表中，仅需用206.0.64.0/22这一个项目，就能把外部发送到这个大学各系的所有分组，都转发到大学的路由器。类比这个路由器是大学的收发室，凡寄给大学任何一个系的邮件，邮递员只需要给收发室，收发室再进行下一步分发。相当于缩短了转发表的查找时间。</p><p>我们可从上图看出，<em><strong>网络前缀越短的地址块所包含的地址数就越多</strong></em></p><h4 id="4-IP地址的特点"><a href="#4-IP地址的特点" class="headerlink" title="4.IP地址的特点"></a>4.IP地址的特点</h4><ol><li>每一个IP地址都由网络前缀和主机号两部分组成。IP是一种<em><strong>分等级的地址结构</strong></em>。分等级的好处：一是IP地址管理机构分配时只<em><strong>分配网络前缀</strong></em>，而剩下的主机号由得到该网络前缀的单位自行分配，方便IP地址的管理。二路由器<em><strong>根据目的主机所连接的网络前缀</strong></em>（即<em><strong>地址块</strong></em>）来转发分组（而不考虑目的主机号），就可以使转发表中的项目数大幅度<em><strong>减少，从而减少转发表所占的存储空间，缩短查找转发表的时间</strong></em></li><li>实际上IP地址是标志一台主机（路由器）和一条链路的<em><strong>接口</strong></em>。一台主机连接两个网络就应有两个相应的IP地址，其网络前缀必须是不同的。这种主机称为<em><strong>多归属主机</strong></em>。路由器至少应连接两个网络，因此路由器至少有两个不同的IP地址。好比一个建筑处于北京路和上海路交叉口上，此建筑可以拥有两个门牌号码，例如北京路1号上海路22号。</li><li>一个网络或子网是指具有相同网络前缀的主机的集合，因此，<em><strong>用转发器或交换机连接起来的若干个局域网仍为一个网络</strong></em>，因为这些局域网都具有同样的网络前缀，具有不同网络前缀的局域网必须使用路由器进行互联。</li><li>在IP地址中，所有分配到网络前缀的网络都是平等的。</li></ol><p>e.g.<br><img src="https://blog.yoobit.cn/img_out/net/net_4_14.png" alt="需要IP地址的地方用小圆圈表示" title="需要IP地址的地方用小圆圈表示"></p><ul><li>在同一个局域网上的主机或路由器的IP地址中的<em><strong>网络前缀必须是同样的</strong></em>，即必须具有同样的网络号。</li><li>图中的网络地址（用粗体字加下划线表示）里面的主机号必定是全0。</li><li>图中以太网交换机连线上画出的小圆圈，是主机或路由器的IP地址，并不是以太网交换机的IP地址。以太网交换机是链路层设备，只有MAC地址。</li><li>以太网交换机（它只在链路层工作）连接的几个网段合起来仍然是一个局域网，只使用同样的网络前缀，例如$LAN~2$。</li><li>路由器总是具有两个或以上的IP地址。即路由器每个接口的IP地址的<em><strong>网络前缀都不同</strong></em>。</li><li>当两个路由器相连时（例如通过一条组用线路），在连线两端的接口处，可以分配也可不分配IP地址。如分配了IP地址，则这一段连线就构成了一种只包含一段线路的特殊“网络”。之所以叫做“网络”，是因为它有IP地址。这种网络仅需两个IP地址，因此这里就使用了/31地址块。这种地址块专门为点对点链路的两端使用。主机号（只有1位）可以是0或1。但为了节省IP地址资源，对于点对点链路构成的特殊“网络”，现在也常常不分配IP地址。通常把这样的特殊网络叫做<em><strong>无编号网络</strong></em>或<em><strong>匿名网络</strong></em>。</li></ul><h3 id="4-2-3-IP地址与MAC地址"><a href="#4-2-3-IP地址与MAC地址" class="headerlink" title="4.2.3 IP地址与MAC地址"></a>4.2.3 IP地址与MAC地址</h3><p>MAC地址固化在网卡上的ROM中，因此常常将MAC地址称为<em><strong>硬件地址</strong></em>或<em><strong>物理地址</strong></em>。IP地址属于虚拟地址、软件地址或逻辑地址此类。</p><p>从层次上看，<em><strong>MAC地址是数据链路层使用的地址</strong></em>，而<em><strong>IP地址是网络层和以上各层使用的地址，是一种逻辑地址</strong></em>（称IP地址位逻辑地址是因为IP地址是用软件实现的）。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_15.png" alt="IP地址与MAC地址的区别" title="IP地址与MAC地址的区别"></p><p>发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用IP地址的IP数据包交给数据链路层后被封装成MAC帧。MAC帧在传送时使用的源地址和目的地址都是MAC地址，这两个MAC地址都写在MAC帧的首部中。</p><p>通信链路上的设备（主机或路由器）在收到MAC帧是，根据首部中MAC地址决定收下或丢弃。只有在剥去MAC帧的首部和尾部后把MAC层的数据上交给网络层，网络层在IP数据包的首部中找到源IP地址和目的IP地址。</p><p>IP地址放在IP数据报的首部，MAC地址放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是MAC地址。当IP数据包插入到数据链路层的MAC帧以后，整个的IP数据包就成为MAC帧的数据，因而在数据链路层看不见数据包的IP地址。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_16.png" alt="从不同层次上看IP地址和MAC地址" title="从不同层次上看IP地址和MAC地址"></p><p>上图中两个路由器R1、R2将三个局域网互连起来，主机H1要与H2通信。通信路径为：H1-&gt;R1转发-&gt;R2转发-&gt;H2。因为R1同时连接到两个局域网上，因此它有两个MAC地址，即MAC3、MAC4，R2同理。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_16_b4.png" alt="图4-16（b）中不同层次、不同区间的源地址和目的地址" title="图4-16（b）中不同层次、不同区间的源地址和目的地址"></p><p>强调：</p><ol><li><em><strong>在IP层抽象的互联网上只能看到IP数据包</strong></em>。</li><li>虽然IP数据报首部有源站IP地址，但<em><strong>路由器只根据目的站的IP地址进行转发</strong></em>。</li><li><em><strong>在局域网的链路层，只能看见MAC帧</strong></em>。MAC帧首部的变化在上面的IP层上是看不见的。</li><li><em><strong>IP层抽象的互联网屏蔽了下层的MAC地址体系不同等复杂的细节</strong></em>。只要我们在网络层上讨论问题，就能够使用<em><strong>统一、抽象</strong></em>的IP地址研究主机和主机或路由器之间的通信。</li></ol><h3 id="4-2-4-地址解析协议ARP"><a href="#4-2-4-地址解析协议ARP" class="headerlink" title="4.2.4 地址解析协议ARP"></a>4.2.4 地址解析协议ARP</h3><p>ARP协议是为了解决知道机器（主机或路由器）的IP地址，再找出相应的MAC地址。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_17.png" alt="协议ARP的作用" title="协议ARP的作用"></p><p>网络层使用的是IP地址，在实际的网络链路上传送数据帧时，使用的还是链路层的MAC地址。</p><p>由于IP地址与MAC地址各式不同不存在简单映射关系，同时在一个网络上经常有新主机加入或撤走一些主机，更换网络适配器也会使主机的MAC地址发生改变。</p><p><em><strong>地址解析协议ARP</strong></em>解决这个问题的方法是在主机的<code>ARP高速缓存(ARP cache)</code>中存放一个IP地址到MAC地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。</p><p>e.g. 当主机A要向本局域网内主机B发送IP数据报时，在ARP高速缓存中查询是否有B的IP地址。</p><p>如有，则在ARP高速缓存中找到对应的MAC地址，再把这个MAC地址写入MAC帧中，通过局域网发生至此MAC地址。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_18.png" alt="地址解析协议ARP的工作原理" title="地址解析协议ARP的工作原理"></p><p>若无，则按以下步骤查询：</p><ol><li>ARP进程再本局域网上广播一个ARP请求分组。</li><li>本局域网上的所有主机运行的ARP进程都收到此ARP请求分组。</li><li>主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下ARP请求分组，并向主机A发送ARP响应分组，同时再ARP响应分组中写入自己的MAC地址。 <em><strong>注意：</strong></em> 虽然ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址。</li><li>主机A收到主机B的ARP响应分组后，就在ARP高速缓存中写入主机B的IP地址到MAC地址的映射。</li></ol><p>主机B随后可能也需要用到A的MAC地址，故在A发出ARP请求分组时，就把自己的IP地址到MAC地址的映射写入ARP请求分组中，B收到请求后将A的地址映射写入自己的ARP高速缓存中。</p><p>ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间，例如10到20分组，反超出生存时间的项目就删除。</p><blockquote><p>注意，ARP用于解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射问题，如果要找的主机和源主机不在同一个局域网上，就需要依次转发如图4-16。</p></blockquote><p>从IP地址到MAC地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</p><p>使用ARP四种典型情况：<br><img src="https://blog.yoobit.cn/img_out/net/net_4_19.png" alt="使用ARP的四种典型情况" title="使用ARP的四种典型情况"></p><ol><li>发送方是主机如H1，要把IP数据包发给同一个网络的另一个主机H2，此时H1发送ARP请求分组，在N1上广播，找到目的主机H2的MAC地址。</li><li>发送方是主机如H1，要发送给另一个网络的一台主机H3，此时H1发送ARP请求分组，在N1上广播，找到N1的一个路由器R1的MAC地址，剩下工作由R1完成，完成3. 或 4.</li><li>发送方是路由器R1，要把IP数据包转发到与R1连接在同一个网络N2上的主机H3，此时R1发送ARP请求分组，在N2上广播，找到目的主机H3的MAC地址。</li><li>发送方是路由器R1，要转发到网络N3上的主机H4，H4与R1不是同一个网络上的，此时R1发送ARP请求分组，在N2上广播，找到路由器R2的地址，剩下工作R2完成。</li></ol><p>多次使用ARP的情况也只是以上几种情况的反复使用。</p><p>为什么要使用IP地址而不直接用MAC地址找到目的主机？</p><blockquote><p>因为各种网络使用不同的MAC地址，如需令这些异构网络相互通信必须<em><strong>进行复杂的MAC地址转换工作</strong></em>，由用户或用户主机来完成几乎是不可能的事。IP编址将连接到互联网的主机之间的通信就像连接在同一个网络上一样简单方便，即使需要多次调用ARP来找到MAC地址，这个过程也是计算机软件自动进行的，对用户来说是看不见的。</p></blockquote><h3 id="4-2-5-IP数据报的格式"><a href="#4-2-5-IP数据报的格式" class="headerlink" title="4.2.5 IP数据报的格式"></a>4.2.5 IP数据报的格式</h3><p>协议IP的标准中，描述首部格式的宽度是32位，即4个字节。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_20.png" alt="IP数据报的格式" title="IP数据报的格式"></p><p>数据包由首部和数据两部分组成，首部前一部分是<em><strong>固定的</strong></em>（20字节），是所有IP数据包必须具有的，后部分是<em><strong>可选字段</strong></em>其长度是可变的（使用较少）。</p><h4 id="1-IP数据报首部的固定部分中的各字段"><a href="#1-IP数据报首部的固定部分中的各字段" class="headerlink" title="1.IP数据报首部的固定部分中的各字段"></a>1.IP数据报首部的固定部分中的各字段</h4><ol><li><em><strong>版本</strong></em> 占4位，指协议IP的版本，这里讨论的是IPv4</li><li><em><strong>首部长度</strong></em> 占4位，可表示的最大十进制数是15。首部长度字段表示的示数单位是32位字长，也就是4个字节。因为IP首部固定部分长度是20字节，因此此字段的最小值是5（即二进制表示的首部长度是0101）。当首部长度字段为最大值1111时，即十进制15，表示首部长度达到最大值60字节。当IP分组的首部长度不是4字节的整数倍时，利用最后的填充字段加以填充。最常用的首部长度是20字节，不使用任何可选字段。</li><li><em><strong>区分服务</strong></em> 占8位，一般情况不使用。</li><li><em><strong>总长度</strong></em> 首部加数据之和的长度，单位为字节，总长度字段为16位，因此数据报的最大长度是$2^{16}-1=65535$字节。实际很少遇到这么长的数据报。<br> 在IP曾下面的每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为<em><strong>最大传送单元MTU</strong></em>，当IP数据报封装成链路层的帧时，数据报的总长度不能超过MTU值，长度超过就需要进行分片处理。最常用的以太网规定MTU值是1500字节。<br> 分片时，（见后续<code>片偏移</code>字段），数据报首部的总长度是指分片后此分片的首部与数据长度之和。</li><li><em><strong>标识（identification）</strong></em> 占16位。分片后，这个标识字段的值就复制给所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li><li><em><strong>标志（flag）</strong></em> 占3位。目前只有两位有意义。<ul><li>最低位<code>MF(More Fragment)</code>.MF=1表示后面<code>还有分片</code>的数据报。MF=0表示这是若干数据报片中的最后一个。</li><li>中间位<code>DF(Don&#39;t Fragment)</code>,意思是<code>不能分片</code>,DF=0时才允许分片。</li></ul></li><li><em><strong>片偏移</strong></em> 占13位。指：较长的分组分片后，某片在原分组中的相对位置。片偏移以8个字节位偏移单位。意味着，除最后一个数据报片外，其他每个分片的长度一定是8个字节（64位）的整数倍。<br> e.g. 一个数据包总长度为3820字节，数据部分长度3800字节，需分片1420字节数据报片。分成3个数据报片，长度分别为1400，1400，1000字节。<br> <img src="https://blog.yoobit.cn/img_out/net/net_4_21.png" alt="数据报的分片举例" title="数据报的分片举例"><br> 标识字段<code>12345</code>是任意给定的。<br> <img src="https://blog.yoobit.cn/img_out/net/net_4_21_b5.png" alt="IP数据报首部中与分片有关的字段中的数值" title="IP数据报首部中与分片有关的字段中的数值"><br> 假定数据报片2在过某个网络时还需要进行分片，即划分为数据报片2-1（携带数据800字节）、数据报片2-2（携带数据600字节）。这两个数据报片的总长度、标识、MF、DF、片偏移分别为:820,12345,1,0,175; 620,12345,0,0,275。</li><li><em><strong>生存时间</strong></em> 占8位，常用缩写TTL（Time To Live）,现功能为“跳数限制”。路由器每次转发数据报之前都把TTl值减1，若TTL减小到0，就丢弃这个数据报，不再转发。因此TTL单位是“跳数”。数据报在互联网中经过的路由器的最大数值是255，若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。</li><li><em><strong>协议</strong></em> 占8位，指出此数据报所携带的数据使用何种协议，以便使目的主机IP层知道将数据部分上交给哪个协议进行处理。<br>常见协议和协议字段值：</li><li><em><strong>首部检验和</strong></em> 占16位，这个字段<em><strong>只检验数据报的首部，不包括数据部分</strong></em>。将IP数据报首部划分为许多16位字的序列，并把检验和字段置0，用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，把首部所有的16位字再使用反码算术运算想加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，此结果必为0，于是就保留这个数据报；否则就认为出错，并丢弃。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_22.png" alt="IP数据报首部检验和的计算过程" title="IP数据报首部检验和的计算过程"></li><li><em><strong>源地址</strong></em> 占32位，发送IP数据报主机的IP地址。</li><li><em><strong>目标地址</strong></em> 占32位，接受IP数据报主机的IP地址。</li></ol><h4 id="2-IP数据报首部的可变部分"><a href="#2-IP数据报首部的可变部分" class="headerlink" title="2.IP数据报首部的可变部分"></a>2.IP数据报首部的可变部分</h4><pre><code class="hljs">首部可变部分就是一个选项字段，用来支持排错、测量以及安全等措施。长度可变取决于所选的项目，从1到40字节不等，有些选项项目需要1字节，有些选项项目需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符。最后用全0的填充字段补齐位4字节的整数倍。增加可变部分增加了IP数据报的功能，同时增加了每个路由器处理数据报的开销，实际上这些选项很少使用，很多路由器都不考虑IP首部的选项字段。因此IPv6就把IP数据报的首部长度做成固定的了。</code></pre><h2 id="4-3-IP层转发分组的过程"><a href="#4-3-IP层转发分组的过程" class="headerlink" title="4.3 IP层转发分组的过程"></a>4.3 IP层转发分组的过程</h2><h3 id="4-3-1-基于终点的转发"><a href="#4-3-1-基于终点的转发" class="headerlink" title="4.3.1 基于终点的转发"></a>4.3.1 基于终点的转发</h3><p>分组在互联网上传送和转发是基于分组首部中的目的地址的，因此这种转发方式称为<em><strong>基于终点的转发</strong></em>。</p><p>分组每到达一个路由器，就根据分组中的目的地址查找转发表，然后得知下一跳到哪个路由器。</p><p>路由器不是直接查找目的主机，而是先查找目的网络（网络前缀），找到目的网络后就把分组在这个网络上直接交付目的主机。从而大大减少压缩转发表的大小。加速分组在路由器中的转发，这就是基于重点的转发过程。</p><p>路由器收到转发分组后，查询出下一跳路由器的IP地址后，通过ARP将路由器的MAC地址放在链路层MAC帧的首部，然后传送给下一个路由器的链路层，下一跳再取出MAC帧的数据部分，交给网络层。</p><p>e.g.分组转发的过程</p><p>三个子网通过两个路由器互联，H1发送一个分组，目的地址是128.1.2.132。目的主机是H2，讨论分组如何传递到目的主机。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_23.png" alt="源主机H1向目的地址H2发送分组" title="源主机H1向目的地址H2发送分组"></p><ol><li>H1先将发送分组的目的地址和本网络N1的子网掩码按位AND运算，得出运算结果。如果等于N1前缀，目的主机就连接在本网络上，否则发送分组至R1，由R1完成后续任务。</li><li>由于采用CIDR记法，转发表给出的都是网络前缀，没有明显给出子网掩码（/后的数字对应就是子网掩码）。例如/26的子网掩码就是点分十进制的255.255.255.192。</li><li>发送分组目的地址是128.1.2.132，本网络掩码是26个1，后面有6个0。<br> <img src="https://blog.yoobit.cn/img_out/net/net_4_24.png" alt="目的地址和本网络的子网掩码按位进行AND运算" title="目的地址和本网络的子网掩码按位进行AND运算"><br> 按位AND运算结果是128.1.2.128，不等于本网络N1前缀，说明目的主机没有连接在本网络上。源主机H1必须发送分组给路由器R1，让R1根据其转发表来进行处理。</li><li>R1部分转发表在4-23右上方给出了。转发表第一列就是“前缀匹配”，因此查找转发表的过程就是<code>寻找前缀匹配的过程</code>。现在检查R1转发表的第一行。源主机H1要发送的分组的目的地址是128.1.2.132.本网络128.1.2.192/26的前缀有26位，按位AND运算的结果是128.1.2.128/26.与第一行的前缀不匹配。</li><li>检查R1转发表的第二行，结果是128.1.2.128/26，匹配。因此按照第二行指出的在N2上进行分组的直接交付（通过R1的接口1）.这时R1调用ARP，解析出目的主机H2的MAC地址，再封装成帧，直接交付连接在本网络N2上的目的主机H2。</li><li>如果再按照同样方法，检查R1转发表中的第三行，得出不匹配的结果。</li></ol><p>从以上例子看出，查找转发表的过程就是逐行寻找前缀匹配的过程。</p><h3 id="4-3-2-最长前缀匹配"><a href="#4-3-2-最长前缀匹配" class="headerlink" title="4.3.2 最长前缀匹配"></a>4.3.2 最长前缀匹配</h3><p>e.g. R1收到一个目的地址为128.1.24.1的分组，给出转发接口。</p><p>公司B采用路由聚合，将三个子网的所有地址聚合为一个网络前缀128.1.24.0/22</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_25.png" alt="分组交给路由器R1进行转发" title="分组交给路由器R1进行转发"></p><p>将R1的分组目的地址分别和转发表第一第二行进行按位AND运算，结果都是匹配，那么那个正确？</p><p>虽然两行计算后的前缀都匹配，但是左侧网络前缀中包含128.1.24.1，但右侧网络中不包含目的地址，只是因为128.1.24.0/22未说明是哪几个子网聚合而成的（并未包含128.1.24.0/24）。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_26.png" alt="公司A和B分到的前缀" title="公司A和B分到的前缀"></p><p>进入R1的分组的目的地址128.1.24.1处于公司A的地址范围中，应通过接口1转发到公司A。</p><p>总结：</p><ul><li>为减少路由器R1中的项目数，公司B采用了地址聚合，将三个地址块聚合为一个地址块128.1.24.0/22。这个形式上与图片左边的前缀一样，就导致出现和两个网络前缀都匹配的现象。</li><li>我们看到如果B公司只分到两个地址块128.1.25.0/24和128.1.26.0/24，聚合地址块仍然是128.1.24.0/22；如果把A、B两公司的地址块都聚合起来，得出的地址块仍为128.1.24.0/22。这样的地址聚合可以发生在路由器R2中。</li></ul><blockquote><p>因此，采用CIDR编址时，如果一个分组在转发表中可以找到多个匹配的前缀，就应当选择前缀最长的一个作为匹配的前缀。这个原则称为<code>最长匹配前缀</code>，网络前缀越长，其地址块就越小，因为路由就最具体。</p></blockquote><p>可以按照前缀长短，将最长的排在第一行，然后按长短的顺序向下排列。用这种方法从第一行前缀最长的开始查找，只要检查到匹配的，就可以立即结束查找。</p><p>实际转发表有时可能增加两种特殊路由，<em><strong>主机路由</strong></em>和<em><strong>默认路由</strong></em></p><p><em><strong>主机路由</strong></em>(host route)又叫做<em><strong>特定主机路由</strong></em>，这是对特定目的主机的IP地址专门指明的一个路由。假定这个特定主机的点分十进制IP地址为a.b.c.d，那么在转发表中对应于主机路由的网络前缀就是a.b.c.d/32，按位AND运算后得到的结果必定是a.b.c.d，也就是说找到了匹配。这时就把收到的分组转发到转发表所指出的下一跳。主机路由在转发表中都放在最前面。</p><p><em><strong>默认路由</strong></em>就是不管分组的最终网络在哪里，都由指定的路由器R来处理。实际转发表中，用一个特殊前缀0.0.0.0/0标识默认路由。</p><p>归纳<code>分组转发算法</code>如下：</p><blockquote><ol><li>从收到的分组的首部提取出目的主机的IP地址D（即目的地址）。</li><li>若查找有特定的主机路由（目的地址为D），就按照这条路由的下一跳转发分组，否则从转发表中下一行（也就是前缀最长的一行）开始检查，执行3</li><li>把这一行的子网掩码与目的地址D按位AND运算。<br> 若匹配，则查找结束，按下一跳进行处理（或直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器）。<br> 否则，若转发表还有下一行，则对下一行进行检查，重新执行3<br> 若转发表没有下一行，执行4</li><li>若转发表中有一个默认路由，则按照指明的接口，把分组传送到指明的默认路由器，否则报告转发分组出错。</li></ol></blockquote><h3 id="4-3-3-使用二叉线索查找转发表"><a href="#4-3-3-使用二叉线索查找转发表" class="headerlink" title="4.3.3 使用二叉线索查找转发表"></a>4.3.3 使用二叉线索查找转发表</h3><p>为了更有效的查找，通常是把无分类编址的转发表存放在一种层次数据结构中，然后自上而下地按层次进行查找。这里最长用的是<code>二叉线索(binary trie)</code>，二叉线索中的各个路径就代表转发表中存放的各个地址。</p><p>图4-27给出了5个IP地址，为了简化二叉线索的结构，先找出对应于每一个IP的<code>唯一前缀(unique prefix)</code>,所谓唯一前缀就是在表中所有IP地址中，该前缀是唯一的。这样在进行查找时，只要能够和唯一前缀相匹配就行了。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_27.png" alt="用5个前缀构成的二叉线索" title="用5个前缀构成的二叉线索"></p><blockquote><p><em>二叉线索/二叉搜索树 见数据结构文章</em></p></blockquote><p>从二叉线索的根节点自顶向下的深度最多32层，每层对应于IP地址的一位。</p><p>假定有一个IP地址10011011 01111010 00000000 00000000，我们从最左边查找，查到第三个字符（即前缀10后面的0）时，在二叉线索中就找不到匹配的，说明这个地址不在这个二叉线索中。</p><p>以上只是给出了二叉线索这种数据结构的用法，并没有说明“与唯一前缀匹配”和“与网络前缀匹配”的关系。显然，必须使二叉线索中的每个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶结点时，就必须将寻找匹配的目的地址和该叶结点的子网掩码按位AND运算，看结果是否与对应的网络前缀相匹配。</p><p>若匹配，就按下一跳的接口转发该分组，否则就丢弃该分组。</p><p>总之，二叉线索只是提供了一种可以快速在转发表中找到匹配叶节点的机制。但这个是否和网络前缀匹配，还要和子网掩码进行一次逻辑AND运算。</p><p>为了提高二叉线索的查找速度，广泛采用了各种<em><strong>压缩技术</strong></em>，例如在图4-27的最后两个地址，最前面4位都是1011，因此，只要一个地址的前4位是1011，就可以跳过前四位（即压缩了4个层次）而直接从第5位开始比较。这样就可以减少查找的时间。</p><h2 id="4-4-网际控制报文协议ICMP"><a href="#4-4-网际控制报文协议ICMP" class="headerlink" title="4.4 网际控制报文协议ICMP"></a>4.4 网际控制报文协议ICMP</h2><p>因特网控制报文协议<code>ICMP（Internet Control Message Protocol）</code>是一个差错报告机制，是TCP/IP协议簇中的一个重要子协议，通常被IP层或更高层协议（TCP或UDP）使用，属于网络层协议，主要用于在IP主机和路由器之间传递控制消息，用于报告主机是否可达、路由是否可用等。这些控制消息虽然并不传输用户数据，但是对于收集各种网络信息、诊断和排除各种网络故障以及用户数据的传递具有至关重要的作用。</p><p><em><strong>为什么需要ICMP？</strong></em> 为了更有效地转发IP数据报和提高交付机会。</p><p>在数据传输的过程中，IP提供尽力而为的服务，指为了把数据包发送到目的地址尽最大努力。它并不对目的主机是否收到数据包进行验证，无法进行流量控制和差错控制。因此在数据包传输过程中，产生各种错误在所难免。为了更有效地转发IP数据包和提高数据包交付成功的机会，ICMP应运而生。使用ICMP，当网络中数据包传输出现问题时，主机或设备就会向上层协议报告差错情况和提供有关异常情况的报告，使得上层协议能够通过自己的差错控制程序来判断通信是否正确，以进行流量控制和差错控制，从而保证服务质量。</p><p>ICMP是IP层协议，ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。也就是一种特殊的IP数据报。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_28.png" alt="ICMP报文的格式" title="ICMP报文的格式"></p><h3 id="4-4-1-ICMP报文的种类"><a href="#4-4-1-ICMP报文的种类" class="headerlink" title="4.4.1 ICMP报文的种类"></a>4.4.1 ICMP报文的种类</h3><p>有两种，即<em><strong>ICMP差错报告报文</strong></em>和<em><strong>ICMP询问报文</strong></em>。</p><p>ICMP报文前4个字节是统一格式，同三个字段：类型、代码和检验和，接着4个字段与ICMP类型有关。最后是数据字段，长度取决于ICMP的类型。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_28_b6.png" alt="几种常用的ICMP报文类型" title="几种常用的ICMP报文类型"></p><p>ICMP报文的代码字段用于进一步区分某种类型中的几种不同情况，检验和字段用来检验整个ICMP报文。</p><blockquote><p>IP数据报首部检验和并不检验IP数据报的内容，因此不能保证经过运输的ICMP报文不产生差错。</p></blockquote><h4 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h4><ol><li><em><strong>终点不可达</strong></em> 主机或路由器不能交付数据报时就像源点发送终点不可达报文。</li><li><em><strong>时间超过</strong></em> 当路由器收到TTL为0的数据报时，除丢弃该数据报外，该要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据片都丢弃，并向源点发送时间超过报文。</li><li><em><strong>参数问题</strong></em> 当路由器或者目的主机收到的数据报的首部中有的字段值不正确时，就丢弃该数据报，并向远点发送参数问题报文。</li><li><em><strong>改变路由（重定向）</strong></em> 路由器把改变路由报文发送给主机，让主机知道下一应将数据报发送给另外的路由器（也就是找到了更好的路由）。</li></ol><p>下面对于改变路由报文进行简短的解释：主机刚开始工作时，一般都在转发表中设置一个默认路由器的IP地址，数据报都先发送给这个默认路由器。这个默认路由器知道每一个目的地址的最佳路由，若发现主机发往某个目的地址的数据报的最佳路由应经过网上的另一个路由器R，就发送改变路由报文告诉主机。于是主机就在其转发表中增加一个项目：到某某目的地址应经过路由器R（而不是目的地址）。</p><p>所有ICMP差错报告报文中的数据字段都具有同样的样式。如图4-29.把收到的需要进行差错报告的IP数据报首部和数据字段的前8个字节提取出来（<code>为得到运输层的端口号（TCP及UDP）以及运输层报文的发送序号（TCP）</code>），作为ICMP报文的数据字段，再加上响应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。整个ICMP报文作为IP数据报的数据字段发送给源点。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_29.png" alt="ICMP差错报告报文的数据字段的内容" title="ICMP差错报告报文的数据字段的内容"></p><p>下面是不应该发送ICMP差错报告报文的几种情况：</p><ul><li>对ICMP差错报告报文，不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片后的所有后续数据报片，都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报，都不发送ICMP差错报告报文</li><li>对具有特殊地址（127.0.0.0或0.0.0.0）的数据报，不发送ICMP差错报告报文</li></ul><h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h4><ol><li><em><strong>回送请求或回送回答</strong></em> 由主机或路由器向一个特定的目的主机发送的询问，收到此报文的主机必须给源主机或路由器发送ICMP会送回答报文。用于测试目的站是否可达以及了解其有关状态。</li><li><em><strong>时间戳请求或时间戳回答</strong></em> 在ICMP时间戳请求报文发出后，就能够收到对方响应的时间戳回答报文。利用报文中记录的时间戳，发送方很容易计算出当前网络的往返时延。</li></ol><h3 id="4-4-2-ICMP的应用举例"><a href="#4-4-2-ICMP的应用举例" class="headerlink" title="4.4.2 ICMP的应用举例"></a>4.4.2 ICMP的应用举例</h3><h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><p>分组网间探测PING(Pacjet InterNet Groper)，用来测试两台主机之间的连通性。</p><p>PING使用了ICMP回送请求与回送回答报文。是应用层直接使用网络层ICMP的一个例子，他没有通过运输层的TCP或者UDP。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_30.png" alt="用PING测试主机的连通性" title="用PING测试主机的连通性"></p><h4 id="traceroute-UNIX-tracert-WIN"><a href="#traceroute-UNIX-tracert-WIN" class="headerlink" title="traceroute(UNIX) tracert(WIN)"></a>traceroute(UNIX) tracert(WIN)</h4><p>用来跟踪一个分组从源点到终点的路径<br><img src="https://blog.yoobit.cn/img_out/net/net_4_30.png" alt="用tracert命令获得目的主机的路由信息" title="用tracert命令获得目的主机的路由信息"></p><h2 id="4-5-IPv6"><a href="#4-5-IPv6" class="headerlink" title="4.5 IPv6"></a>4.5 IPv6</h2><p>因IPv4地址全部耗尽，在2017年7月终于发布了IPv6的正式标准[RFC 8200, STD86]</p><p>本文章暂不介绍IPv6.</p><h2 id="4-6-互联网的路由选择协议"><a href="#4-6-互联网的路由选择协议" class="headerlink" title="4.6 互联网的路由选择协议"></a>4.6 互联网的路由选择协议</h2><p>本章讨论记中常用的路由选择协议，也就是要讨论转发表中的路由时怎样得出的。按4.1.2观点，路由选择协议属于网络层控制层面的内容。本节按照传统思路进行讨论，路由选择协议规定了互联网中有关路由器应如何互相交换信息并生成出路由表的。</p><h3 id="4-6-1-有关路由选择协议的几个基本概念"><a href="#4-6-1-有关路由选择协议的几个基本概念" class="headerlink" title="4.6.1 有关路由选择协议的几个基本概念"></a>4.6.1 有关路由选择协议的几个基本概念</h3><h4 id="1-理想的路由算法"><a href="#1-理想的路由算法" class="headerlink" title="1.理想的路由算法"></a>1.理想的路由算法</h4><p>路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点(BELL86]：</p><ol><li><em><strong>算法必须是正确的和完整的</strong></em>。这里，“正确”的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li><em><strong>算法在计算上应简单</strong></em>。路由选择的计算不应使网络通信量增加太多的额外开销。</li><li><em><strong>算法应能适应通信量和网络拓扑的变化</strong></em>，这就是说，要有自适应性。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些节点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为 “<em><strong>稳健性</strong></em> ”(robustness)（鲁棒性）。</li><li><em><strong>算法应具有稳定性</strong></em>。在网络通信量和网络拓扑相对稳定的情況下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li><li><em><strong>算法应是公平的</strong></em>。路由选择算法应对所有用户(除对少数优先级高的用广）都是平等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显地不符合公平性的要求。</li><li><em><strong>算法应是最佳的</strong></em>。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到“最佳” 的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，<em><strong>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已</strong></em>。</li></ol><p>一个实际的路由选择算法，应尽可能接近于理想的算法，在不同应用条件下，对以上提出的6个方面也可由不同的侧重。</p><p>从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即<em><strong>静态路由选择策略</strong></em>与<em><strong>动态路由选择策略</strong></em>。静态路由选择也叫做<em><strong>非自适应路由选择</strong></em>，特点是简单和开销小，但不能及时适应网络状态地变化。对于很小的网络，完全可以采用静态路由选择，用人工配置每一条路由。动态路由选择也叫做<em><strong>自适应路由选择</strong></em>，特点是能较好适应网络状态的变化，但实现起来较为复杂，开销也比较大，适用于较复杂的大网络。</p><h4 id="2-分层次的路由选择协议"><a href="#2-分层次的路由选择协议" class="headerlink" title="2.分层次的路由选择协议"></a>2.分层次的路由选择协议</h4><p>互联网采取的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。</p><p>主要原因：</p><ol><li>互联网规模非常大。</li><li>许多单位不愿意外界了解自己单位网络布局细节和本部门所采取的路由选择协议，但同时还希望连接到互联网上。</li></ol><p>因此，整个互联网划分为许多小的<em><strong>自治系统</strong></em>(autonomouos system)，一般记为AS。自治系统AS是在单一技术管理下的许多网络、IP地址以及路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。每一个AS对其他的AS表现出的是<em><strong>一个单一的和一致的路由选择策略</strong></em>[RFC 4271]。</p><p>这样，互联网把路由选择协议划分为两大类：</p><ol><li><em><strong>内部网关协议IGP(Interior Gateway Protocol)</strong></em> 即在一个自治系统内部使用的路由选择协议，与其他AS选用什么路由选择协议无关。常用为RIP、OSPF、IS-IS协议。</li><li><em><strong>外部网关协议EGP(External Gateway Protocol)</strong></em> 源主机和目的主机处在不同的AS之中，在不同AS之间的路由选择就需要使用外部网关协议EGP，目前最多使用是BGP-4</li></ol><p>AS之间的路由选择也叫做<em><strong>域间路由选择(interdomain routing)<em><strong>，在AS内部的路由选择叫做</strong></em>域内路由选择(intradomain routing)</strong></em></p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_39.png" alt="自治系统和内部网关协议、外部网关协议" title="自治系统和内部网关协议、外部网关协议"></p><blockquote><p>注意： 互联网早期RFC文档未使用“路由器”而使用“网关”一词，后续改用“路由器”一词。因此IGP协议和EGP协议有的文章书籍改为IRP（内部路由器协议）和ERP（外部路由器协议）。</p></blockquote><h3 id="4-6-2-内部网关协议RIP"><a href="#4-6-2-内部网关协议RIP" class="headerlink" title="4.6.2 内部网关协议RIP"></a>4.6.2 内部网关协议RIP</h3><h4 id="1-协议RIP的工作原理"><a href="#1-协议RIP的工作原理" class="headerlink" title="1.协议RIP的工作原理"></a>1.协议RIP的工作原理</h4><p>RIP(Routing Information Protocol)是内部网关协议，中文译名是路由信息协议。RIP是一种分布式的<em><strong>基于距离向量的路由选择协议</strong></em>。</p><p>RIP协议的距离也称为<em><strong>跳数(hop count)</strong></em>,并且每经过一个网络跳数就加1，RIP允许一条路径最多只能包含15个网络，因此距离等于16时即相当于不可达，可见<em><strong>RIP只适用于小型互联网</strong></em>。</p><p>RIP不能在两个网络之间同时使用多条路由，RIP选择一条具有最少网络数的路由（即最短路由），哪怕还存在另一条高速（低时延）但网络数较多的路由。</p><p>协议RIP的特点是：</p><ol><li><em><strong>仅和相邻路由器交换信息</strong></em>。</li><li>交换信息时<em><strong>当前路由器所知道的全部信息，即自己现在的路由表</strong></em>。</li><li><em><strong>按固定时间间隔交换路由信息</strong></em>。网络中的主机虽然叶运行协议RIP，但只被动接收路由器发来的路由信息。</li></ol><p>路由器在刚刚开始工作时，路由表是空的，路由器得出到直接相连的几个网络的距离（这些距离定义为1）。接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。若干次更新后，所有的路由器都会知道到达本AS中任何一个网络的最短距离和下一跳路由器的地址。</p><p>路由表更新的原则就是找出到每个目的网络的<em><strong>最短距离</strong></em>。这种更新算法又称为<em><strong>距离向量算法</strong></em>。</p><h4 id="2-距离向量算法"><a href="#2-距离向量算法" class="headerlink" title="2.距离向量算法"></a>2.距离向量算法</h4><p>RIP报文中每个项目都有三个关键数据：到目的网络Net，距离是d，下一跳路由器是M。</p><p>对<em><strong>每一个相邻的路由器</strong></em>（地址为X）发送过来的RIP报文，执行以下步骤：</p><p>Bellman-Ford算法：</p><ol><li>修改接收的RIP报文中的所有项目：把<code>下一跳</code>字段地址都改为X，并把<code>距离</code>字段的值加1。</li><li>对修改后的每一个项目，进行以下步骤：<br>若原来的路由表中没有目的网络Net，则将该项目添加到路由表中。<br>否则（即在路由表中有Net，这时再查看下一跳路由地址）。<br>若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目。<br>否则（即收到的这个项目是：到目的网络Net，但下一跳路由器不是X）<br>若收到的项目中距离d小于路由表中的距离，则进行更新，<br>否则什么也不做。<br>伪代码解释：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(原来的路由表中没有目的地址Net)&#123;<br>    将该项目添加到路由表中<br>&#125;<br><span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//在路由表中有Net</span><br>    <span class="hljs-keyword">if</span>(下一跳路由器地址是X)&#123;<br>        收到的项目替换原路由表中的项目<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//到目的网络Net，但下一跳路由器不是X</span><br>        <span class="hljs-keyword">if</span>(收到的项目中距离d小于路由表中的距离)&#123;<br>            更新<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//距离d大于路由表中的距离</span><br>            什么也不做<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为16（距离16表示不可达）。</li><li>返回</li></ol><p>Bellman-Ford算法的要点：</p><blockquote><p>设X是节点A到B的最短路径上的一个节点。若把路径A-&gt;B拆成两端路径A-&gt;X和X-&gt;B，则对每一段路径A-&gt;X和X-&gt;B也都分别是节点A到节点X和节点X到节点B的最短路径。</p></blockquote><p>e.g. 已知路由器R6路由表，现在收到相邻路由器R4发来的路由更新信息。需更新R6的路由表。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_39_b8.png" alt="路由表与更新信息" title="路由表与更新信息"></p><p>解答：</p><p>先将表4-8(b)中的距离都加1，并把下一跳路由器都改为R4，得出表4-8(c)<br><img src="https://blog.yoobit.cn/img_out/net/net_4_39_bc.png" alt="修改后的表4-8(b)" title="修改后的表4-8(b)"></p><p>将此表与表4-8(a)进行比较，</p><ol><li>第一行在表4-8(a)中没有，因此要将这一行添加到表4-8(a)中</li><li>第二行的Net2在表4-8(a)中有，且下一跳路由器也是R4，因此更新（距离增大了）。</li><li>第三行的Net3在表4-8(a)中有，但下一跳路由器不同，于是比较距离，新的路由信息的距离是2，小于原来的4，因此要更新。</li></ol><p>更新后的R6的路由表如下：</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_39_bd.png" alt="路由器R6更新后的路由表" title="路由器R6更新后的路由表"></p><p>协议RIP让一个AS中的所有路由器都和自己相邻路由器定期交换路由信息，并不断更新其路由表，使得从<em><strong>每一个路由器到每一个目的网络的路由都是最短的</strong></em>(即跳数最少)。</p><p>虽然所有的路由器最终都拥有了整个自治系统AS的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p><p>现在较新的版本是1998年11月公布的RIP2。支持无分类域间路由选择CIDR。还提供简单的鉴别过程支持多播。</p><p>下图表明RIP报文作为运输层用户数据报UDP的数据部分进行传送（使用UDP的端口520）。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_40.png" alt="RIP2的报文用UDP用户数据报传送" title="RIP2的报文用UDP用户数据报传送"></p><p>RIP报文由首部和路由部分组成。在路由部分要填入<em><strong>自治系统号ASN</strong></em>(Autonomous System Number)，这是为了考虑到RIP有可能收到本自治系统以外的路由选择信息。还要指出<em><strong>目的网络地址</strong></em>（包括网络的<em><strong>子网掩码</strong></em>）、<em><strong>下一跳路由器地址</strong></em>以及<em><strong>到此网络的距离</strong></em>。一个RIP报文最多可包括25个路由，如超过，必须要用一个RIP报文来传送。</p><h4 id="3-坏消息传播得慢"><a href="#3-坏消息传播得慢" class="headerlink" title="3.坏消息传播得慢"></a>3.坏消息传播得慢</h4><p>RIP存在<em><strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong></em>。</p><p>我们可以用图 4-41 的简单例子来说明。设三个网络通过两个路由器互连起来，并且都己建立了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内容。路由器R1中的“Net1， 1，直接” 表示“到网 Net1 的距离是 1，直接交付”。路由器R2中的“Net1, 2,R1”表示“到网 Net1 的距离是2，下一跳经过R1”。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_41.png" alt="协议RIP的缺点：坏消息传播得慢" title="协议RIP的缺点：坏消息传播得慢"></p><p>现在假定路由器R1到网Net1 的链路出了故障，R1无法到达网 Net1。于是路由器R1把到网 Netl 的距离改为16，表示不可达，因而在 R1的路由表中的相应项目变为“Net1，16，直接”。但是，很可能要经过 30秒钟后 R1才把更新信息发送给 R2。然而 R2可能已经先把自己的路由表发送给了R1，其中有“Net1，2，R1”这一项。</p><p>R1收到 R2的更新报文后，误认为可经过 R2到达网 Net1，于是把收到的路由信息“Net1，2，R1”修改为:“Net1，3，R2”，表明“我到网Net1 的距离是3，下一跳经过R2”，并把更新后的信息发送给 R2。</p><p>同理，R2接着又更新自己的路由表为“Net1，4，R1”，以为“我到网 Net1 距离是4，下跳经过R1”</p><p>这样的更新一直继续下去，直到R1和R2到网 Net1 的距离都增大到 16 时，R1和R2才知道原来网 Net1 是不可达的。协议 RIP 的这一特点叫作:好消息传播得快，而坏消息传播得慢。网络出故障的传播时间往往较长(例如数分钟)。这是 RIP 的一个主要缺点。但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。</p><p>为了使坏消息传播得更快些，可以采取多种措施。例如，让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送。</p><p>总之，协议 RIP 最大的优点就是实现简单，开销较小。但协议 RIP 的缺点也较多。</p><p>首先，RIP 限制了网络的规模，它能使用的最大距离为 15(16 表示不可达)。其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用下一节所述的OSPF协议。然而目前在规模较小的网络中，使用协议 RIP 的仍占多数。</p><h3 id="4-6-3-内部网关协议OSPF"><a href="#4-6-3-内部网关协议OSPF" class="headerlink" title="4.6.3 内部网关协议OSPF"></a>4.6.3 内部网关协议OSPF</h3><h4 id="1-协议OSPF的基本特点"><a href="#1-协议OSPF的基本特点" class="headerlink" title="1.协议OSPF的基本特点"></a>1.协议OSPF的基本特点</h4><p>这个协议的名字是<em><strong>开放最短路径有限OSPF</strong></em>(Open Shortest Path First)。为克服RIP的缺点开发，原理很简单，实现较复杂。“<em><strong>最短路径优先</strong></em>”是因为使用了<em><strong>Dijkstra</strong></em>提出的<em><strong>最短路径算法SPF</strong></em>。</p><p>注意：OSPF只是一个协议的名字，并不代表其他的路由选择协议不是“最短路径优先”。事实上所有的在AS内部使用的路由选择协议包括（RIP）都是要寻找一条最短路径。</p><p>OSPF最主要特征是使用<em><strong>链路状态协议(link state protocol)</strong></em></p><p>OSPF的特点是：</p><ol><li>通过洪泛法(flooding)向本AS中所有路由器发送信息。每一个相邻路由器继续发往其所有的相邻路由器。</li><li>发送的信息是与本路由器<em><strong>相邻的所有路由器的链路状态</strong></em>，这只是路由器所知道的部分信息。链路状态说明本路由器都与哪些路由器相邻，以及该链路的“度量(metric)”。OSPF用这个“度量”用来表示费用、距离、时延、带宽等。又称为“代价”。</li><li>当链路状态发生变化或每隔一段时间（如30分钟），路由器向所有路由器用洪泛法发送链路状态信息。</li></ol><p>由于各路由器之间频繁交换链路状态信息，因此所有路由器最终都能建立一个<em><strong>链路状态数据库</strong></em>(link-state database),这个数据库实际上就是<em><strong>全网的拓扑结构图</strong></em>，这个拓扑结构在全网内是一致的，称为链路状态数据库的同步。因此每一个路由器都知道全网一共有多少各路由器，以及哪些路由器是相连的、代价是多少等。</p><p>每一个路由器用链路状态数据库中的数据，构造出自己的路由表（例如使用Dijkstra的最短路径路由算法）。</p><p>OSPF的链路状态数据库能较快更新，使每个路由器能及时更新其路由表，OSPF的<em><strong>更新过程收敛得快</strong></em>是其重要优点。</p><p>为了使OSPF能够用于规模很大的网络，OSPF将一个AS再划分为若干个更小的范围，叫做<em><strong>区域</strong></em>(area)。如下图将一个AS划分为四个区域。</p><p>每个区域都有一个32位的区域标识符（用点分十进制形式表示）。一个区域内路由器最好不超过200个。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_42.png" alt="OSPF划分为两个不同的区域" title="OSPF划分为两个不同的区域"></p><p>OSPF使用层次结构的区域划分，在上层区域叫做<em><strong>主干区域</strong></em>(backbone area)，标识符规定为0.0.0.0。主干区域作用是联通在下层的区域。</p><p>从其他区域来的信息都由<em><strong>区域边界路由器</strong></em>(area border router)进行概括。</p><p>图4-42中，</p><ul><li>R3，R4，R7都是区域边界路由器。</li><li>R3，R4，R5，R6，R7都是主干路由器。</li><li>一个主干路由器可以同时是边界路由器，如R3，R4，R7。</li><li>R6为<em><strong>自治系统边界路由器</strong></em>，目的为和本AS外的其他AS交换路由信息。</li></ul><p>采用分层次划分区域的方法使交换信息的种类增多了，同时使OSPF协议更复杂了，但可以使每一个区域内部交换路由信息的通信量大大减少。</p><p>除以上特点，OSPF还具有以下一些特点：</p><ol><li>OSPF允许管理员给每条路由指派不同的代价。<em><strong>对于不同类型的业务可以计算出不同的路由</strong></em>。代价可以是1至65535中的任何一个无量纲的数。</li><li>多路径间的<em><strong>负载均衡</strong></em>(load balancing):如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。</li><li>所有再OSPF路由器之间交换的分组（例如链路状态更新分组）都具有鉴别的功能，因而保证了尽在可信赖的路由器之间交换链路状态信息。</li><li>OSPF支持可变长度的子网划分和无分类的编址CIDR。</li><li>由于网络中的链路状态可能经常发生变化，因此OSPF让每一个链路状态都带上个32位的序号，序号越大状态就越新。OSPF规定，链路状态序号增长的速率不得超过每5秒钟1次。这样，全部序号空间在600年内不会产生重复号。</li></ol><h4 id="2-OSPF的五种分组（数据报）类型"><a href="#2-OSPF的五种分组（数据报）类型" class="headerlink" title="2.OSPF的五种分组（数据报）类型"></a>2.OSPF的五种分组（数据报）类型</h4><p>一共有以下五种分组类型：</p><ol><li><em><strong>问候</strong></em>(Hello)分组，用来发现和维持邻站的可达性。</li><li><em><strong>数据库描述</strong></em>(Database Description)分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li><em><strong>链路状态请求</strong></em>(Link State Request)分组，向对方请求发送某些链路状态项目的详细信息。</li><li><em><strong>链路状态更新</strong></em>(Link State Update)分组，用洪泛法对全网更新链路状态。路由器使用这种分组将其链路状态通知给邻站。</li><li><em><strong>链路状态确认</strong></em>(Link State Acknowledgment)分组，对链路更新分组的确认。</li></ol><p>OSPF分组是作为IP数据报的数据部分来传送的，OSPF不用UDP而直接使用IP数据报发送（其IP数据报首部的协议字段值为89）。</p><p>OSPF构成的数据报很短，好处如下：</p><ul><li>减少路由信息的通信量。</li><li>不必将长的数据报分片传送。（分片传送的数据报只要丢失一个，整个数据报就必须重传）</li></ul><p><img src="https://blog.yoobit.cn/img_out/net/net_4_43.png" alt="OSPF分组用IP数据报传送" title="OSPF分组用IP数据报传送"></p><p>OSPF规定，每两个相邻路由器每隔10秒就要交换一次问候分组，从而确定哪些邻站是可达的。</p><p>正常情况下，网络中传送的绝大多数OSPF分组都是问候分组。如果40秒没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，同时重新计算路由表。</p><p>其他四种分组都是用来进行数据链路数据库的同步，所谓<em><strong>同步</strong></em>就是指不同路由器的链路状态数据库的内容是一样的。两个同步的路由器叫做“<em><strong>完全邻接的</strong></em>”(fully adjacent)路由器。不是完全邻接的路由器虽然物理上相邻的，但其链路状态数据库并没有达到一致。</p><p>当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工作以及将数据发往相邻路由器所需的“代价”。</p><p>如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态数据库。但这样做开销太大，因此OSPF 采用下面的办法。</p><ol><li>OSPF让每一个路由器用 数据库描述分组 和 相邻路由器 交换本数据库中已有的链路状态摘要信息。（摘要信息主要就是指出有哪些路由器的链路状态信息（及其序号）已经写入了数据库）</li><li>与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。</li><li>通过一系列这种分组交换，全网同步的链路数据库就建立了。</li></ol><p>在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，泛洪向全网更新链路状态。OSPF使用<em><strong>可靠的洪泛法</strong></em>，是收到更新分组后要发送确认（收到重复的更新分组只需要发送一次确认）。如下图：<br><img src="https://blog.yoobit.cn/img_out/net/net_4_44.png" alt="用可靠的洪泛法发送更新分组" title="用可靠的洪泛法发送更新分组"></p><p>为确保链路状态数据库与全网的状态保持一致，OSPF规定每隔一段时间，如30分组要刷新一次数据库中的链路状态。</p><p>由于一个路由器的链路状态只涉及与相邻路由器的连通状态，因为与整个互联网的规模并无直接关系。因此互联网规模很大时，OSPF协议要比距离向量协议RIP好很多。</p><p>若 N 个路由器连接在一个以太网上，则每个路由器要向其他(N - 1)个路由器发送链路状态信息，因而共有 N(N-1)个链路状态要在这个以太网上传送。OSPF 协议对这种多点接入的局域网采用了<em><strong>指定的路由器</strong></em>(designated router：DR)和备份指定路由器（BDR）的方法，使广播的信息量大大减少，减小多路访问网络中OSPF流量。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_44_dr.png" alt="指定路由器DR与备份指定路由器BDR运行图" title="指定路由器DR与备份指定路由器BDR运行图"></p><p>如图：当DR和BDR选举完成之后，R4将路由通告给R1和R2，然而R2作为BDR，此时他知道DR还在（不会去代替DR，去通告其他DRother），所以R2收到路由存放在本地之后不会通告出去，而是由BR通告给R3。此时减少了重复通告，优化设备性能。</p><h3 id="4-6-4-外部网关协议BGP"><a href="#4-6-4-外部网关协议BGP" class="headerlink" title="4.6.4 外部网关协议BGP"></a>4.6.4 外部网关协议BGP</h3><h4 id="1-协议BGP的主要特点"><a href="#1-协议BGP的主要特点" class="headerlink" title="1.协议BGP的主要特点"></a>1.协议BGP的主要特点</h4><p>在<em><strong>外部网关协议</strong></em>（或<em><strong>边界网关协议</strong></em>）BGP中，现在使用第四版GBP-4，常简写为BGP。</p><p>BGP协议将全世界数以万计AS联系在一起构成一个完整的互联网。</p><p>我们知道内部网关协议（如RIP/OSPF）主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站，在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。主要是因为以下两个原因：</p><ol><li><em><strong>互联网的规模太大，使得自治系统AS之间路由选择非常困难</strong></em>。<ul><li>在互联网主干路由器中，一个转发表项目数甚至可达到50万个网络前缀，如果使用链路状态协议，每个路由器必须维持一个很大的链路状态数据库，查询时间也太长。</li><li>当一个路径通过几个不同的AS时，计算出有意义的代价是不太可能的。</li></ul></li><li><em><strong>自治系统AS之间的路由选择必须考虑有关策略</strong></em>。<br>BGP只能力求选择出一条能够到达目的网络前缀且比较好的路由（不能兜圈子），而并非要计算出一条最佳路由。这里说的BGP路由，是指经过哪些自治系统AS可以到达目的的网络前缀。这选择出的比较好的路由，有时不严格地称为最佳路由。BGP采用了<em><strong>路径向量</strong></em>(path vector)路由选择协议，与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大区别。</li></ol><h4 id="2-BGP路由"><a href="#2-BGP路由" class="headerlink" title="2.BGP路由"></a>2.BGP路由</h4><p>一个AS中有不同功能的路由器，即<em><strong>边界路由器</strong></em>（或<em><strong>边界网关</strong></em>）和<em><strong>内部路由器</strong></em>。一个AS至少要有一个边界路由器和相邻AS的边界路由器直接相连。正是由于有了边界路由器，AS之间才能利用协议BGP交换可达性路由信息。</p><p>当两个边界路由器（R1和R2）进行通信时，必须先建立TCP连接（端口号179），这种TCP连接称为半永久性连接（即双方交换完信息后仍然保持着连接状态）。R1和R2之间的这种连接称为<em><strong>eBGP连接</strong></em>，e表示外部external。现在，边界路由器R1可通过eBGP向对等端发送BGP路由“X，AS1，R1”，意思是“从R1经AS1可到达X”。这样，通过eBGP连接，AS2中的边界路由器R2就知道了到达AS1中的前缀X的BGP路由。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_45.png" alt="AS之间eBGP连接(a)和AS内部的iBGP连接(b)" title="AS之间eBGP连接(a)和AS内部的iBGP连接(b)"></p><p>边界路由器R2应把获得的BGP路由，再转发给AS内部的其他路由器。为此，协议BGP规定，在AS内部，两个路由器之间还需要建立iBGP（也就是iGBP连接，i表示internal），iBGP也是用TCP连接传送BGP报文。上图表示边界路由器R2在三个iBGP连接上，向AS2内部的其他三个路由器转发自己收到的GBP路由。至此，AS2内的所有路由器都知道了这条BGP路由信息。由此可见，协议BGP并非仅运行在AS之上，而且也要运行在AS的内部。</p><p>BGP规定，在一个AS内部的所有iBGP必须是全连通的，即使两个路由器之间没有物理连接，但它们之间仍然有iBGP连接。如下图。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_46.png" alt="在AS内路由器之间的物理连接与iBGP连接" title="在AS内路由器之间的物理连接与iBGP连接"></p><p>图4-45(a)中的边界路由器R1通告给边界路由器 R2的BGP 路由可能有很多条(在图中只画出了一条)。但R2根据本AS管理员所规定的策略，可以拒绝某些路由(收到这种路由后即删除掉)，而在iBGP连接上仅转发符合规定策略的BGP路由。</p><p>eBGP和iBGP协议是同一个协议，两种不同连接上传送的BGP报文，都遵循同样的协议BGP，使用同样的报文格式具有同样的属性类型。</p><p>唯一的不同点就是在发送BGP路由通告时的规则有所不同。这就是，从eBGP对等端收到的BGP路由，可通过iBGP告诉同一AS内的对等端。反过来也是可以的，即从iBGP对等端收到的BGP 路由，可通过eBGP告诉在不同AS的对等端。但是从BGP对等端收到BGP路由，不能转告给同一个AS内不同iBGP的对等端。</p><p>图4-47形象地说明了eBGP和BGP的作用。图中画出了四个自治系统AS，每一个AS都必须运行本AS选择的内部网关协议IGP，例如OSPF或RIP。而协议BGP是在BGP连接和eBGP连接之上运行的。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_47.png" alt="协议BGP在iBGP和eBGP之上运行" title="协议BGP在iBGP和eBGP之上运行"></p><p>BGP路由的一般格式：</p><blockquote><p>BGP路由 = “前缀，BGP属性” = “前缀，AS-PATH，NEXT-HOP”</p></blockquote><p><em><strong>前缀</strong></em>就是通告的BGP路由<em><strong>终点</strong></em>（子网前缀）</p><p><em><strong>BGP属性</strong></em>有好几种类型，最重要的就是AS-PATH和NEXT-HOP。</p><p><em><strong>AS-PATH</strong></em>(自治系统路径) 是通告的BGP路由所经过的自治系统。BGP路由每经过一个一个AS就将其<em><strong>自治系统号ASN</strong></em>加入到AS-PATH中。BGP路由必须指出通过哪些AS，而不指出路由途中需要通过哪些路由器。</p><p><em><strong>NEXT-HOP</strong></em>(下一跳) 是通告的BGP路由起点。</p><p>如下图，R4在收到BGP路由“X，AS1，R1”后知道了“从R1出发就能够到达AS1中的前缀X”，应如何构造自己的转发表？</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_48.png" alt="BGP路由的起点、经过的AS和终点" title="BGP路由的起点、经过的AS和终点"></p><ol><li><p>R4将BGP路由的起点进行转换，从“R1-&gt;X” ，现要将R1改成对等端R2，把BGP路由变成“R2-&gt;R1-&gt;X”</p></li><li><p>由于R2位于AS2中，因此AS2里所有的路由器都能把分组转发到R2，然后经过R1，最终到达前缀X</p></li><li><p>R4利用内部网关协议，找到R4到R2的最佳路由中的下一跳。本例中查出下一跳是R3，于是R4在转发表中增加了到达前缀X的下一跳是R3这一项目。</p><table><thead><tr><th>前缀匹配</th><th>下一跳</th><th>注释</th></tr></thead><tbody><tr><td>X</td><td>R3</td><td>转发表中有下一跳R3表示前缀X可达</td></tr></tbody></table></li><li><p>类似的方法，R3也在转发表中增加到达前缀X的项目</p><table><thead><tr><th>前缀匹配</th><th>下一跳</th><th>注释</th></tr></thead><tbody><tr><td>X</td><td>R2</td><td>转发表中有下一跳R2表示前缀X可达</td></tr></tbody></table></li><li><p>路由器R4只要收到要到达前缀X的分组，都按照R4-&gt;R3-&gt;R2-&gt;R1-&gt;X的路径最后到达X</p></li></ol><p>每一个路由器收到一条新的BGP路由通告后，必须经过上述步骤，才能在自己的转发表中，增加到达终点的“下一跳”的相应项目。</p><p>实际转发表中，“前缀匹配”项目都用CIDR记法表示。由于路由器有两个以上的接口，因此“下一跳”用进入该路由的接口的IP地址表示。</p><h4 id="3-三种不同的自治系统AS"><a href="#3-三种不同的自治系统AS" class="headerlink" title="3.三种不同的自治系统AS"></a>3.三种不同的自治系统AS</h4><p>AS分为三大类：即<em><strong>末梢AS</strong></em>(stub AS)、<em><strong>穿越AS</strong></em>(transit AS)、<em><strong>对等AS</strong></em>(peering AS)。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_49.png" alt="几种不同类型AS" title="几种不同类型AS"></p><p>末梢AS</p><ul><li>末梢AS是比较小的AS，如AS4、AS5和AS6。</li><li>这些分组与直接连接的分组交换分组，但不会把接收到的分组转发给另一个AS。</li><li>末梢AS必须向所连接的AS付费才能收发分组。</li><li>末梢AS也可以同时连接到两个或以上AS，如AS5，这种称为<em><strong>多归属AS</strong></em>(multihomed AS)。</li><li>末梢AS不允许分组穿越自己的自治系统，如AS5不能把来自AS3的分组转发给AS2。</li><li>末梢AS5不能把（AS5-&gt;AS2-&gt;AS4）这样的BGP路由信息通告给AS3.</li><li>如果AS3有分组要转发给AS4，可以通过对等AS2转发，但不能通过末梢AS5</li></ul><p>穿越AS</p><ul><li>AS1是穿越AS，往往是拥有很好的高速通信干线的主干AS。</li><li>任务是为其他AS有偿转发分组。</li><li>通常会有很多AS连接到穿越AS上。</li></ul><p>对等AS</p><ul><li>如AS2和AS3</li><li>事先协商</li><li>彼此之间发送接收分组不收费。</li></ul><p>BGP路由必须避免兜圈子的出现。当AS-PATH中出现与自己相同AS，就应删除此BGP路由。</p><blockquote><p>在属性AS-PATH中不允许出现相同的AS。</p></blockquote><h4 id="4-BGP的路由选择"><a href="#4-BGP的路由选择" class="headerlink" title="4.BGP的路由选择"></a>4.BGP的路由选择</h4><p>如果到前缀X有两条或更多BGP路由可供选择，就按照以下原则，按照这里给出的先后顺序，选择一条较好的BGP路由。</p><ol><li><em><strong>本地偏好LOCAL-PREF</strong></em>(LOCAL PREFerence)<em><strong>值</strong></em>最高的路由要首要选择。<br>在BGP路由中的属性里有一个选项叫做本地偏好，可由管理员根据政治、经济策略来设置。<br>例如：从R1离开AS1的BGP路由属性LOCAL-PREF值设为300，把从R2离开AS1的BGP路由的LOCAL-PREF值设为200。通过iBGP通告AS1内部的所有路由器。这样，凡是有分组要转发到AS4，都优先选择从R1离开AS1。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_50.png" alt="LOCAL-PREF值较高的路由优先" title="LOCAL-PREF值较高的路由优先"><br>即使此链路负荷过重，协议BGP也无法调整负载。<br>如果找不出本地偏好值最高的路由，执行下一条：</li><li>选择具有<em><strong>AS跳数最少</strong></em>的路由<br><img src="https://blog.yoobit.cn/img_out/net/net_4_51.png" alt="根据经过AS跳数的多少选择BGP路由" title="根据经过AS跳数的多少选择BGP路由"><br>根据AS跳数少的原则，可能会经过更多次的转发，反而花费更长的时间。</li><li>使用<em><strong>热土豆路由选择算法</strong></em><br>将分组比喻为烫手的热土豆，要尽快转发出去。要让分组经过最少的转发次数离开本AS。使用内部网关协议（RIP或者OSPF）。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_52.png" alt="热土豆路由选择算法的应用举例（图中的连接都是物理连接）" title="热土豆路由选择算法的应用举例（图中的连接都是物理连接）"><br>故对于R1，转发路径应是：R1-&gt;R4-&gt;BGP路由2<br>R2，转发路由时：R2-&gt;R3-&gt;BGP路由1</li><li>选择路由器<em><strong>BGP标识符</strong></em>的数值最小的路由<br>以上几种方法都无法找到最好的BGP路由时，使用此方法。<br>在BGP进行交互的报文中，首部有一4字节字段，称为BGP标识符，记为BGP ID。具有多个接口路由器有多个IP，BGP ID就使用该路由器的IP地址中数值最大的一个。</li></ol><h4 id="5-BGP的四种报文"><a href="#5-BGP的四种报文" class="headerlink" title="5.BGP的四种报文"></a>5.BGP的四种报文</h4><p>协议BGP刚运行时，BGP连接的对等端要相互交换整个BGP路由表，但之后只需要在BGP路由表变化时，才有更新变化的部分。这样对节省网络带宽和减少路由器处理开销方面都有好处。</p><p>BGP-4的四种报文：</p><ol><li>OPEN（打开）报文。用来与BGP连接对等端建立关系。</li><li>UPDATE（更新）报文。用来通告某一路由的信息，以及列出要撤销的路由。</li><li>KEEPALIVE（保活）报文。用来周期性证实与对等端的连通性。</li><li>NOTIFICATION（通知）报文。用来发送检测到的差错。</li></ol><p>两个路由器之间建立TCP连接后就发送OPEN报文，作用是识别对方，同时协商一些协议参数（如计时器时间）。收到OPEN后发送KEEPALIVE报文表示接收BGP连接。</p><p>UPDATE报文时BGP协议的核心，用来撤销以前通知过的路由，或宣布增加新的路由。撤销可以一次多条，但更新一次只能一条。</p><p>由于不可知TCP上层BGP是否始终正常工作，对等端定期传递BGP路由表会使网络通信量过大。故使两对等端之间周期性交换KEEPALIVE报文。KEEPALIVE只包含BGP报文的首部（19字节长）。</p><p>每一个路由器都有一个<em><strong>保持时间计时器</strong></em>(Hold Timer)。路由器每收到一个BGP报文，计时器重置一次从0开始计时。如果商定时间内没有收到对等端发来的任何BGP报文，就认为对方不能工作了。</p><p>发送KEEPALIVE报文时间间隔取为双方商定的<em><strong>保持时间</strong></em>(Hold Time)的1/3，如建立连接阶段商定为180秒，则每隔60秒发送一次KEEPALIVE报文。如两对等端选择的保持时间不一致，则选数值较小的一个作为彼此使用的保持时间。保持时间设为0时，永远不发送KEEPALIVE，表明这条BGP连接总是正常工作的。</p><p>ASN升级到4字节后，ASN范围扩大，使得互联网中存在两种不同的BGP报文。</p><p>BGP报文是作为TCP报文的数据部分来传送的，四种类型的BGP报文具有同样的首部。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_53.png" alt="BGP报文用TCP报文传送" title="BGP报文用TCP报文传送"></p><h3 id="4-6-5-路由器的构成"><a href="#4-6-5-路由器的构成" class="headerlink" title="4.6.5 路由器的构成"></a>4.6.5 路由器的构成</h3><h4 id="1-路由器的结构。"><a href="#1-路由器的结构。" class="headerlink" title="1.路由器的结构。"></a>1.路由器的结构。</h4><p>路由器是一种具有多个输入输出端口的专用计算机，其任务是转发分组。</p><p>从路由器某个输入端口收到的分组，按照分组要去的目的地(即目的网络)，把该分组从路由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。路由器的转发分组正是网络层的主要工作。</p><p><img src="https://blog.yoobit.cn/img_out/net/net_4_54.png" alt="典型路由器结构" title="典型路由器结构"></p><p>路由器划分为两大部分：<em><strong>路由选择</strong></em>部分和<em><strong>分组转发</strong></em>部分。</p><p>路由选择部分也叫做<em><strong>控制部分</strong></em>或<em><strong>控制层面</strong></em>，核心构件是路由选择处理机。任务是根据选定的路由选择协议构造出路由表，并定期交换路由信息，更新和维护路由表。</p><p>分组转发也就是<em><strong>数据层面</strong></em>，由<em><strong>交换结构</strong></em>、一组<em><strong>输入端口</strong></em>、一组<em><strong>输出端口</strong></em>（硬件接口）组成。</p><ol><li><em><strong>交换结构</strong></em>(switching fabric)又称交换组织。作用是根据转发表对分组进行处理，将某输入端口进入的分组从一个合适输出端口转发出去。</li><li>输入输出端口对线路上收到的分组会在网络层的处理模块设有一个缓冲区，输出端口同样具备。<br><img src="https://blog.yoobit.cn/img_out/net/net_4_55.png" alt="输入端口" title="输入端口"><br><img src="https://blog.yoobit.cn/img_out/net/net_4_56.png" alt="输出端口" title="输出端口"><br>当路由器输入输出队列产生溢出时候，会发生分组丢失，设备与线路故障也可能使分组丢失。</li></ol><h4 id="2-交换结构"><a href="#2-交换结构" class="headerlink" title="2.交换结构"></a>2.交换结构</h4><p><img src="https://blog.yoobit.cn/img_out/net/net_4_57.png" alt="三种常用的交换方法" title="三种常用的交换方法"></p><ol><li><em><strong>通过存储器</strong></em>：分组从输入输出端口复制到存储器内，处理机从分组首部提取到目的地址，查找路由表，再将分组复制到合适的输出端口缓存中。</li><li><em><strong>通过总线</strong></em>：这种方法不需要路由选择处理机的干预，但同一时间只能有一个分组再总线上传送。</li><li><em><strong>纵横交换结构</strong></em>(crossbar switch fabric):这种交换机常称为互连网络(interconnection network)。有2N条总线，可以使N个输入端口和N个输出端口相连。例如：当分组从A进入输出到Y，就把总线A和Y的交叉节点闭合。如果还有一个分组从B到Z，也可同时进行。<br> 特点是：<ul><li>只要这个输出端口没有被别的分组占用，分组就可以转发到任何一个输出端口。</li><li>如果这个输出端口（即对应的垂直总线）已被占用，后到达的分组就必须在输入端口排队等待。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档</tag>
      
      <tag>基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 快速教程</title>
    <link href="/2022/11/04/Redis/"/>
    <url>/2022/11/04/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-快速教程"><a href="#Redis-快速教程" class="headerlink" title="Redis 快速教程"></a>Redis 快速教程</h1><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p><h2 id="阅读本教程前，您需要了解的知识？"><a href="#阅读本教程前，您需要了解的知识？" class="headerlink" title="阅读本教程前，您需要了解的知识？"></a>阅读本教程前，您需要了解的知识？</h2><p>阅读本教程前，你需要了解基本的数据结构，例如以下几种：</p><ul><li>String: 字符串</li><li>Hash: 散列</li><li>List: 列表</li><li>Set: 集合</li><li>Sorted Set: 有序集合</li></ul><p>在阅读本教程前，你需要了解基本的数据结构。</p><h1 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h1><h2 id="Redis-简介-1"><a href="#Redis-简介-1" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h2 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h2><ul><li><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p></li><li><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p></li></ul><h1 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h1><h2 id="Linux-源码安装"><a href="#Linux-源码安装" class="headerlink" title="Linux 源码安装"></a>Linux 源码安装</h2><p>下载地址：<a href="http://redis.io/download">http://redis.io/download</a>，下载最新稳定版本。</p><p>本教程使用的最新文档版本为 2.8.17，下载并安装：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> http://download.redis.io/releases/redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">8</span>.tar.gz<br><span class="hljs-attribute">tar</span> xzf redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">8</span>.tar.gz<br><span class="hljs-attribute">cd</span> redis-<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>执行完 make 命令后，redis-6.0.8 的 src 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli：</p><p>下面启动 redis 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src<br>./redis-server<br></code></pre></td></tr></table></figure><p>注意这种方式启动 redis 使用的是默认配置。也可以通过启动参数告诉 redis 使用指定配置文件使用下面命令启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src<br>./redis-server ../redis.conf<br></code></pre></td></tr></table></figure><p><code>redis.conf</code> 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</p><p>启动 <code>redis</code> 服务进程后，就可以使用测试客户端程序 <code>redis-cli</code> 和 <code>redis</code> 服务交互了。 比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src<br>./redis-cli<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">redis&gt; <span class="hljs-built_in">set</span> foo bar<br>OK<br>redis&gt; <span class="hljs-built_in">get</span> foo<br><span class="hljs-string">&quot;bar&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h1><p>Redis 的配置文件位于 <code>Redis</code> 安装目录下，文件名为 <code>redis.conf</code>。</p><p>你可以通过 CONFIG 命令查看或设置配置项。</p><h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>Redis支持五种数据类型：<code>string</code>（字符串），<code>hash</code>（哈希），<code>list</code>（列表），<code>set</code>（集合）及<code>zset</code>(sorted set：有序集合)。</p><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><p><strong>实例</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">redis 127.0.0.1:6379&gt; <span class="hljs-built_in">SET</span> zibier <span class="hljs-string">&quot;Zibier&#x27;s Blog&quot;</span><br>OK<br>redis 127.0.0.1:6379&gt; <span class="hljs-built_in">GET</span> zibier<br><span class="hljs-string">&quot;Zibier&#x27;s Blog&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://blog.yoobit.cn/php/img/Redis/redis_set.jpg" alt="实例1" title="实例1"></p><p>在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 zibier，对应的值为 Zibier’s Blog。</p><p>注意：一个键最大能存储 512MB。</p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p><strong>实例</strong></p><p><code>DEL zibier</code> 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">HMSET zibier field1 <span class="hljs-string">&quot;Hello&quot;</span> field <span class="hljs-string">&quot;World&quot;</span><br>(error) WRONGTYPE Operation against a key holding the wrong kind of value<br><span class="hljs-number">127.0.0.1:6379</span>&gt; DEL zibier<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; HMSET zibier field1 <span class="hljs-string">&quot;Hello&quot;</span> field2 <span class="hljs-string">&quot;World&quot;</span><br>OK<br></code></pre></td></tr></table></figure><p><img src="https://blog.yoobit.cn/php/img/Redis/redis_hash.jpg" alt="HASH实例" title="HASH实例"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">redis</span> <span class="hljs-number">127.0.0.1:6379</span>&gt; DEL zibier<br>redis <span class="hljs-number">127.0.0.1:6379</span>&gt; HMSET zibier field1 <span class="hljs-string">&quot;Hello&quot;</span> field2 <span class="hljs-string">&quot;World&quot;</span><br><span class="hljs-string">&quot;OK&quot;</span><br>redis <span class="hljs-number">127.0.0.1:6379</span>&gt; HGET zibier field1<br><span class="hljs-string">&quot;Hello&quot;</span><br>redis <span class="hljs-number">127.0.0.1:6379</span>&gt; HGET zibier field2<br><span class="hljs-string">&quot;World&quot;</span><br></code></pre></td></tr></table></figure><p>实例中我们使用了 Redis <strong>HMSET</strong>, <strong>HGET</strong> 命令，<strong>HMSET</strong> 设置了两个 field=&gt;value 对, HGET 获取对应 <strong>field</strong> 对应的 <strong>value</strong>。</p><p>每个 hash 可以存储 $2^{32}$ -1 键值对（40多亿）。</p><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p><strong>实例</strong></p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tcl">redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; DEL zibier<br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush zibier redis<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush zibier mongodb<br>(integer) <span class="hljs-number">2</span><br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush zibier rabbitmq<br>(integer) <span class="hljs-number">3</span><br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> zibier <span class="hljs-number">0</span> <span class="hljs-number">10</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;rabbitmq&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;mongodb&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;redis&quot;</span><br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;<br></code></pre></td></tr></table></figure><p>列表最多可存储 $2^{32}$ - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p><strong>sadd 命令</strong></p><p>添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。</p><pre><code class="hljs">sadd key member</code></pre><p><strong>实例</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; DEL zibier<br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; sadd zibier redis<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; sadd zibier mongodb<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; sadd zibier rabbitm<span class="hljs-string">q</span><br><span class="hljs-string">(integer)</span> <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; sadd zibier rabbitm<span class="hljs-string">q</span><br><span class="hljs-string">(integer)</span> <span class="hljs-number">0</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; smembers zibier<br><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;redis&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;rabbitmq&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;mongodb&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p></blockquote><p>集合中最大的成员数为 $2^{32}$ - 1(4294967295, 每个集合可存储40多亿个成员)。</p><h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><p><strong>zadd 命令</strong></p><p>添加元素到集合，元素在集合中存在则更新对应score</p><pre><code class="hljs">zadd key score member</code></pre><p><strong>实例</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl">redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; DEL zibier<br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; zadd zibier <span class="hljs-number">0</span> redis<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; zadd zibier <span class="hljs-number">0</span> mongodb<br>(integer) <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; zadd zibier <span class="hljs-number">0</span> rabbitm<span class="hljs-string">q</span><br><span class="hljs-string">(integer)</span> <span class="hljs-number">1</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; zadd zibier <span class="hljs-number">0</span> rabbitm<span class="hljs-string">q</span><br><span class="hljs-string">(integer)</span> <span class="hljs-number">0</span><br>redis <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; ZRANGEBYSCORE zibier <span class="hljs-number">0</span> <span class="hljs-number">1000</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;mongodb&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;rabbitmq&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;redis&quot;</span><br></code></pre></td></tr></table></figure><h2 id="各数据类型应用场景"><a href="#各数据类型应用场景" class="headerlink" title="各数据类型应用场景"></a>各数据类型应用场景</h2><table><thead><tr><th>类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td>String(字符串)</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—</td></tr><tr><td>Hash(字典)</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td>List(列表)</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td>Set(集合)</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td>Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档</tag>
      
      <tag>基础</tag>
      
      <tag>Redis</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA 面向对象编程</title>
    <link href="/2022/11/01/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/11/01/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p><p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p>面向对象的基本概念，包括：</p><ul><li>类</li><li>实例</li><li>方法</li></ul><p>面向对象的实现方式，包括：</p><ul><li>继承</li><li>多态</li></ul><p>Java语言本身提供的机制，包括：</p><ul><li>package</li><li>classpath</li><li>jar</li></ul><p>以及Java标准库提供的核心类，包括：</p><ul><li>字符串</li><li>包装类型</li><li>JavaBean</li><li>枚举</li><li>常用工具类<h2 id="一、面向对象基础"><a href="#一、面向对象基础" class="headerlink" title="一、面向对象基础"></a>一、面向对象基础</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h3>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</li></ul><p>现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：</p><h4 id="定义class"><a href="#定义class" class="headerlink" title="定义class"></a>定义class</h4><p>在Java中，创建一个类，例如，给这个类命名为<code>Person</code>，就是定义一个<code>class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个class可以包含多个字段（<code>field</code>），字段用来描述一个类的特征。上面的<code>Person</code>类，我们定义了两个字段，一个是<code>String</code>类型的字段，命名为<code>name</code>，一个是<code>int</code>类型的字段，命名为<code>age</code>。因此，通过<code>class</code>，把一组数据汇集到一个对象上，实现了数据封装。</p><p><code>public</code>是用来修饰字段的，它表示这个字段可以被外部访问。</p><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。</p><p>new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：</p><pre><code class="hljs">Person ming = new Person();</code></pre><p>述代码创建了一个<code>Person</code>类型的实例，并通过变量<code>ming</code>指向它。</p><p>注意区分<code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例。</p><p>有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">ming.name = <span class="hljs-string">&quot;Xiao Ming&quot;</span>; <span class="hljs-comment">// 对字段name赋值</span><br>ming.age = <span class="hljs-number">12</span>; <span class="hljs-comment">// 对字段age赋值</span><br>System.out.println(ming.name); <span class="hljs-comment">// 访问字段name</span><br><br><span class="hljs-type">Person</span> <span class="hljs-variable">hong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>hong.name = <span class="hljs-string">&quot;Xiao Hong&quot;</span>;<br>hong.age = <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在OOP中，<code>class</code>和<code>instance</code>是“模版”和“实例”的关系；</p><p>定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例；</p><p><em>class定义的field，在每个instance都会拥有各自的field，且互不干扰；</em></p><p>通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance；</p><p>访问实例字段的方法是变量名.字段名；</p><p><em>指向instance的变量都是引用变量</em>。</p><hr><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><p>一个<code>class</code>可以包含多个<code>field</code>，例如，我们给<code>Person</code>类就定义了两个<code>field</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，直接把<code>field</code>用<code>public</code>暴露给外部可能会破坏封装性。比如，代码可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">ming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>ming.name = <span class="hljs-string">&quot;Xiao Ming&quot;</span>;<br>ming.age = -<span class="hljs-number">99</span>; <span class="hljs-comment">// age设置为负数</span><br></code></pre></td></tr></table></figure><p>显然，直接操作<code>field</code>，容易造成逻辑混乱。为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要使用方法（<code>method</code>）来让外部代码可以间接修改<code>field</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">ming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        ming.setName(<span class="hljs-string">&quot;Xiao Ming&quot;</span>); <span class="hljs-comment">// 设置name</span><br>        ming.setAge(<span class="hljs-number">12</span>); <span class="hljs-comment">// 设置age</span><br>        System.out.println(ming.getName() + <span class="hljs-string">&quot;, &quot;</span> + ming.getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;invalid age value&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p><p>对<code>setName()</code>方法同样可以做检查，例如，不允许传入<code>null</code>和空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || name.isBlank()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;invalid name&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.name = name.strip(); <span class="hljs-comment">// 去掉首尾空格</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样，外部代码不能直接读取<code>private</code>字段，但可以通过<code>getName()</code>和<code>getAge()</code>间接获取<code>private</code>字段的值。</p><p>所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。</p><p>调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加;。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ming.setName(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><p>定义方法的语法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">修饰符 方法返回类型 方法名(方法参数列表) &#123;<br>    若干方法语句;<br>    <span class="hljs-keyword">return</span> 方法返回值;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="private方法"><a href="#private方法" class="headerlink" title="private方法"></a>private方法</h4><p>定义<code>private</code>方法的理由是内部方法是可以调用<code>private</code>方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">ming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        ming.setBirth(<span class="hljs-number">2008</span>);<br>        System.out.println(ming.getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> birth;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBirth</span><span class="hljs-params">(<span class="hljs-type">int</span> birth)</span> &#123;<br>        <span class="hljs-built_in">this</span>.birth = birth;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> calcAge(<span class="hljs-number">2019</span>); <span class="hljs-comment">// 调用private方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// private方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcAge</span><span class="hljs-params">(<span class="hljs-type">int</span> currentYear)</span> &#123;<br>        <span class="hljs-keyword">return</span> currentYear - <span class="hljs-built_in">this</span>.birth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察上述代码，<code>calcAge()</code>是一个<code>private</code>方法，外部代码无法调用，但是，内部方法<code>getAge()</code>可以调用它。</p><p>此外，我们还注意到，这个<code>Person</code>类只定义了<code>birth</code>字段，没有定义<code>age</code>字段，获取<code>age</code>时，通过方法<code>getAge()</code>返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心<code>Person</code>实例在内部到底有没有<code>age</code>字段。</p><h4 id="this变量"><a href="#this变量" class="headerlink" title="this变量"></a>this变量</h4><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。<br>如果没有命名冲突，可以省略this。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name; <span class="hljs-comment">// 相当于this.name</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// 前面的this不可少，少了就变成局部变量name了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><p>方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNameAndAge</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用这个<code>setNameAndAge()</code>方法时，必须有两个参数，且第一个参数必须为<code>String</code>，第二个参数必须为<code>int</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">ming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>ming.setNameAndAge(<span class="hljs-string">&quot;Xiao Ming&quot;</span>); <span class="hljs-comment">// 编译错误：参数个数不对</span><br>ming.setNameAndAge(<span class="hljs-number">12</span>, <span class="hljs-string">&quot;Xiao Ming&quot;</span>); <span class="hljs-comment">// 编译错误：参数类型不对</span><br></code></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用 <strong>类型XXX</strong> 定义，可变参数相当于数组类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Group</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] names;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNames</span><span class="hljs-params">(String... names)</span> &#123;<br>        <span class="hljs-built_in">this</span>.names = names;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Group</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>();<br>g.setNames(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-string">&quot;Xiao Hong&quot;</span>, <span class="hljs-string">&quot;Xiao Jun&quot;</span>); <span class="hljs-comment">// 传入3个String</span><br>g.setNames(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-string">&quot;Xiao Hong&quot;</span>); <span class="hljs-comment">// 传入2个String</span><br>g.setNames(<span class="hljs-string">&quot;Xiao Ming&quot;</span>); <span class="hljs-comment">// 传入1个String</span><br>g.setNames(); <span class="hljs-comment">// 传入0个String</span><br></code></pre></td></tr></table></figure><p>完全可以把可变参数改写为<code>String[]</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Group</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] names;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNames</span><span class="hljs-params">(String[] names)</span> &#123;<br>        <span class="hljs-built_in">this</span>.names = names;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，调用方需要自己先构造String[]，比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Group</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>();<br>g.setNames(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-string">&quot;Xiao Hong&quot;</span>, <span class="hljs-string">&quot;Xiao Jun&quot;</span>&#125;); <span class="hljs-comment">// 传入1个String[]</span><br></code></pre></td></tr></table></figure><p>另一个问题是，调用方可以传入<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Group</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>();<br>g.setNames(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。</p><h4 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h4><p>调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。</p><p>那什么是参数绑定？</p><p>我们先观察一个基本类型参数的传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>; <span class="hljs-comment">// n的值为15</span><br>        p.setAge(n); <span class="hljs-comment">// 传入n的值</span><br>        System.out.println(p.getAge()); <span class="hljs-comment">// 15</span><br>        n = <span class="hljs-number">20</span>; <span class="hljs-comment">// n的值改为20</span><br>        System.out.println(p.getAge()); <span class="hljs-comment">// 15还是20?</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，从结果可知，修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响。</p><blockquote><p>结论：<strong>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        String[] fullname = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;Homer&quot;</span>, <span class="hljs-string">&quot;Simpson&quot;</span> &#125;;<br>        p.setName(fullname); <span class="hljs-comment">// 传入fullname数组</span><br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Homer Simpson&quot;</span><br>        fullname[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Bart&quot;</span>; <span class="hljs-comment">// fullname数组的第一个元素修改为&quot;Bart&quot;</span><br>        System.out.println(p.getName()); <span class="hljs-comment">// &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;?</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.name[<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String[] name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！</p><blockquote><p>结论：<strong>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象）</strong>。</p></blockquote><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li><p>方法可以让外部代码安全地访问实例字段；</p></li><li><p>方法是一组执行语句，并且可以执行任意逻辑；</p></li><li><p>方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；</p></li><li><p>外部代码通过public方法操作实例，内部代码可以调用private方法；</p></li><li><p>理解方法的参数绑定。</p></li></ul><hr><h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h3><p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建<code>Person</code>实例的时候，一次性传入<code>name</code>和<code>age</code>，完成初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Mao&quot;</span>,<span class="hljs-number">22</span>);<br>        System.out.println(<span class="hljs-string">&quot;姓名是：&quot;</span>+p.getName());<br>        System.out.println(<span class="hljs-string">&quot;年龄是：&quot;</span>+p.getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">姓名是：Mao<br>年龄是：22<br></code></pre></td></tr></table></figure><p>由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。</p><h4 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h4><p>存在默认无参构造方法<code>Person()</code>，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法。</p><p>如果需要带参数构造方法与无参构造方法同时存在，则需要在类内都进行定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Mao&quot;</span>,<span class="hljs-number">22</span>);<br>        System.out.println(<span class="hljs-string">&quot;姓名是：&quot;</span>+p.getName());<br>        System.out.println(<span class="hljs-string">&quot;年龄是：&quot;</span>+p.getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">// 默认初始化为null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">// 默认初始化为0</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时可以对字段直接进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Unamed&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ul><li><p>先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；</p></li><li><p>执行构造方法的代码进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Unamed&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法的代码由于后运行，所以，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>的字段值最终由构造方法的代码确定。</p></li></ul><h4 id="多构造方法"><a href="#多构造方法" class="headerlink" title="多构造方法"></a>多构造方法</h4><p>可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Mao&quot;</span>,<span class="hljs-number">22</span>);<br>        System.out.println(<span class="hljs-string">&quot;姓名是：&quot;</span>+p.getName());<br>        System.out.println(<span class="hljs-string">&quot;年龄是：&quot;</span>+p.getAge());<br>        Person p2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Oliver&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;姓名是：&quot;</span>+p2.getName());<br>        System.out.println(<span class="hljs-string">&quot;年龄是：&quot;</span>+p2.getAge());<br>        Person p3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(<span class="hljs-string">&quot;姓名是：&quot;</span>+p3.getName());<br>        System.out.println(<span class="hljs-string">&quot;年龄是：&quot;</span>+p3.getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=<span class="hljs-number">22</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=<span class="hljs-string">&quot;未定义&quot;</span>;<br>        <span class="hljs-built_in">this</span>.age=<span class="hljs-number">22</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果调用<code>new Person(&quot;Mao&quot;, 22);</code>，会自动匹配到构造方法<code>public Person</code>(String, int)。</p><p>如果调用<code>new Person(&quot;Mao&quot;);</code>，会自动匹配到构造方法<code>public Person(String)</code>。</p><p>如果调用<code>new Person();</code>，会自动匹配到构造方法<code>public Person()</code>。</p><p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>(name, <span class="hljs-number">18</span>); <span class="hljs-comment">// 调用另一个构造方法Person(String, int)</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;Unnamed&quot;</span>); <span class="hljs-comment">// 调用另一个构造方法Person(String)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li><p>实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例；</p></li><li><p>没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；</p></li><li><p>可以定义多个构造方法，编译器根据参数自动判断；</p></li><li><p>可以在一个构造方法内部调用另一个构造方法，便于代码复用。</p></li></ul><hr><h3 id="4-方法重载"><a href="#4-方法重载" class="headerlink" title="4. 方法重载"></a>4. 方法重载</h3><p>在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个<code>hello()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hi, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法名相同，但各自的参数不同，称为<strong>方法重载（<code>Overload</code>）</strong>。</p><blockquote><p><em><strong>注意：方法重载的返回值类型通常都是相同的。</strong></em></p></blockquote><p>举个例子，String类提供了多个重载方法indexOf()，可以查找子串：</p><ul><li><p><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</p></li><li><p><code>int indexOf(String str)</code>：根据字符串查找；</p></li><li><p><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</p></li><li><p><code>int indexOf(String str, int fromIndex)</code>:根据字符串查找，但指定起始位置。</p></li></ul><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li><p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p></li><li><p>重载方法应该完成类似的功能，参考String的indexOf()；</p></li><li><p>重载方法返回值类型应该相同。</p></li></ul><hr><h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h3><p>我们已经定义了Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们需要新建学生类就可以使用 <strong>继承</strong></p><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p><p>Java使用extends关键字来实现继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 不要重复name和age字段/方法,</span><br>    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123; … &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，通过继承，Student只需要编写额外的功能，不再需要重复代码。</p><blockquote><p><em><strong>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</strong></em></p></blockquote><p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）。</p><p>意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。</p><p>Java只允许一个<code>class</code>继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// 编译错误：无法访问name字段</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protecte</code>d。用<code>protected</code>修饰的字段可以被子类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// OK!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问</p><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>super关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">super</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p><p>如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><p>完整继承构造代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Mao&quot;</span>,<span class="hljs-number">22</span>,<span class="hljs-number">100</span>);<br>        System.out.println(s1.getName());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>   <span class="hljs-keyword">protected</span> String name;<br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>       <span class="hljs-built_in">this</span>.age = age;<br>       <span class="hljs-built_in">this</span>.name = name;<br>   &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age,<span class="hljs-type">int</span> score)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name,age);<br>        <span class="hljs-built_in">this</span>.score=score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h4><p>正常情况下，只要某个<code>class</code>没有<code>final</code>修饰符，那么任何类都可以从该<code>class</code>继承。</p><p>从Java 15开始，允许使用<code>sealed</code>修饰<code>class</code>，并通过<code>permits</code>明确写出能够从该<code>class</code>继承的子类名称。</p><p>例如，定义一个Shape类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> permits Rect, Circle, Triangle &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>这样写是没问题的。</p><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>如果<code>Student</code>是从<code>Person</code>继承下来的，那么，一个引用类型为<code>Person</code>的变量，能指向<code>Student</code>类型的实例</p><p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p><p>这种把一个子类类型安全地变为父类类型的赋值，被称为<strong>向上转型（upcasting）</strong>。</p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> s; <span class="hljs-comment">// upcasting, ok</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> p; <span class="hljs-comment">// upcasting, ok</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> s; <span class="hljs-comment">// upcasting, ok</span><br></code></pre></td></tr></table></figure><p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">// upcasting, ok</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Student) p1; <span class="hljs-comment">// ok</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Student) p2; <span class="hljs-comment">// runtime error! ClassCastException!</span><br></code></pre></td></tr></table></figure><p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>System.out.println(p <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span><br>System.out.println(p <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span><br><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>System.out.println(s <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span><br>System.out.println(s <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// true</span><br><br><span class="hljs-type">Student</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>System.out.println(n <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Student) &#123;<br>    <span class="hljs-comment">// 只有判断成功才会向下转型:</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student) p; <span class="hljs-comment">// 一定会成功</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Object obj=<span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> String)&#123;<br>            String s=(String) obj;<br>            System.out.println(s.toUpperCase())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以改写为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;<br>            <span class="hljs-comment">// 可以直接使用变量s:</span><br>            System.out.println(s.toUpperCase());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h4><p>在使用继承时，我们要注意逻辑一致性。</p><p>例如我们有一个Book类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再Book类内也有name字段,那么Student类能否继承自Book类呢?</p><p>显然，从逻辑上讲，这是不合理的，Student不应该从Book继承，而应该从Person继承。</p><p>究其原因，是因为Student是Person的一种，它们是is关系，而Student并不是Book。实际上Student和Book的关系是has关系。</p><p>具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> Book book;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> score;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，继承是is关系，组合是has关系。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul><li><p>继承是面向对象编程的一种强大的代码复用方式；</p></li><li><p>Java只允许单继承，所有类最终的根类是Object；</p></li><li><p>protected允许子类访问父类的字段和方法；</p></li><li><p>子类的构造方法可以通过super()调用父类的构造方法；</p></li><li><p>可以安全地向上转型为更抽象的类型；</p></li><li><p>可以强制向下转型，最好借助instanceof判断；</p></li><li><p>子类和父类的关系是is，has关系不能用继承。</p></li></ul><hr><h3 id="6-多态"><a href="#6-多态" class="headerlink" title="6. 多态"></a>6. 多态</h3><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。<br>例如，在<code>Person</code>类中，我们定义了<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person.run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在子类<code>Student</code>中，覆写这个<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Student.run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Override</code>和<code>Overload</code> (重载)不同的是，如果方法签名不同，就是<code>Overload</code>，<code>Overload</code>方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p><blockquote><p><em><strong>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</strong></em></p></blockquote><p><code>@Override</code>不是必需的。</p><p><strong>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        p.run(); <span class="hljs-comment">// 打印Student.run</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person.run&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student.run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Student.run<br></code></pre></td></tr></table></figure><p>这个非常重要的特性在面向对象编程中称之为 <strong>多态</strong>。它的英文拼写非常复杂：<code>Polymorphic</code>。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p><p>多态的特性是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span><br>        Income[] incomes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Income</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Income</span>(<span class="hljs-number">3000</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Salary</span>(<span class="hljs-number">7500</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCouncilSpecialAllowance</span>(<span class="hljs-number">15000</span>)<br>        &#125;;<br>        System.out.println(totalTax(incomes));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">totalTax</span><span class="hljs-params">(Income... incomes)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Income income: incomes) &#123;<br>            total = total + income.getTax();<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Income</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> income;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Income</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span> &#123;<br>        <span class="hljs-built_in">this</span>.income = income;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> income * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 税率10%</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Salary</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span> &#123;<br>        <span class="hljs-built_in">super</span>(income);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (income &lt;= <span class="hljs-number">5000</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StateCouncilSpecialAllowance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StateCouncilSpecialAllowance</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span> &#123;<br>        <span class="hljs-built_in">super</span>(income);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p><p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p><h4 id="覆写Object方法"><a href="#覆写Object方法" class="headerlink" title="覆写Object方法"></a>覆写Object方法</h4><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p><p><code>toString()</code>：把<code>instance</code>输出为<code>String</code>；</p><p><code>equals()</code>：判断两个<code>instance</code>是否逻辑相等；</p><p><code>hashCode()</code>：计算一个<code>instance</code>的哈希值。</p><p>在必要的情况下，我们可以覆写Object的这几个方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Mao&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Mao&quot;</span>);<br>        System.out.println(p.toString());<br>        System.out.println(p.equals(p2));<br>        System.out.println(p.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-comment">// 显示更有意义的字符串:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person:name=&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-comment">// 比较是否相等:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">// 当且仅当o为Person类型:</span><br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) o;<br>            <span class="hljs-comment">// 并且name字段相同时，返回true:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算hash:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h4><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Mao&quot;</span>);<br>        System.out.println(s1.hello());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用父类的hello()方法:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.hello() + <span class="hljs-string">&quot;!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// compile error: 不允许覆写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>&#125;<br><br><span class="hljs-comment">// compile error: 不允许继承自Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Unamed&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在构造方法中初始化<code>final</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改。</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul><li><p>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</p></li><li><p>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</p></li><li><p><code>final</code>修饰符有多种作用：</p><ul><li><p><code>final</code>修饰的方法可以阻止被覆写；</p></li><li><p><code>final</code>修饰的<code>class</code>可以阻止被继承；</p></li><li><p><code>final</code>修饰的<code>field</code>必须在创建对象时初始化，随后不可修改。</p></li></ul></li></ul><hr><h3 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7. 抽象类"></a>7. 抽象类</h3><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>由于多态的存在，每个子类都可以覆写父类的方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; … &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; … &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p><p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p><p>因为无法执行抽象方法，因此这个类也必须声明为抽象类（<code>abstract class</code>）。</p><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p><pre><code class="hljs">Person p = new Person(); // 编译错误</code></pre><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法,也就是出现在抽象类里的抽象方法 <strong>必须在子类中覆写</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        p.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student.run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h4><p>当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例：</p><pre><code class="hljs">Person s = new Student();Person t = new Teacher();</code></pre><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：</p><pre><code class="hljs">// 不关心Person变量的具体子类型:s.run();t.run();</code></pre><p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p><pre><code class="hljs">// 同样不关心新的子类是如何实现run()方法的：Person e = new Employee();e.run();</code></pre><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li><p>上层代码只定义规范（例如：<code>abstract class Person</code>）；</p></li><li><p>不需要子类就可以实现业务逻辑（正常编译）；</p></li><li><p>具体的业务逻辑由不同的子类实现，调用者并不关心。</p></li></ul><p>用抽象类给一个有工资收入和稿费收入的小伙伴算税，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span><br>    &#123;<br>        Income[] incomes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Income</span>[] &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SalaryIncome</span>(<span class="hljs-number">7500</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoyaltyIncome</span>(<span class="hljs-number">12000</span>)<br>        &#125;;<br>        System.out.println(getTotalTax(incomes));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTotalTax</span><span class="hljs-params">(Income... incomes)</span>&#123;<br>        <span class="hljs-type">double</span> total=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Income income:incomes)&#123;<br>            total+=income.getTax();<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计税的抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">abstract</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Income</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> income;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Income</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.income = income;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工资计税</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryIncome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SalaryIncome</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>(income);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.income &lt;= <span class="hljs-number">5000</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 稿费计税</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RoyaltyIncome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RoyaltyIncome</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>(income);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.income * <span class="hljs-number">0.1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTotalTax</span><span class="hljs-params">(Income... incomes)</span>&#123;<br>        <span class="hljs-type">double</span> total=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Income income:incomes)&#123;<br>            total+=income.getTax();<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>Income... incomes</code>中<code>...</code>是代表可以接受多个实际参数，这里的多个指的是不限个数，可以是一个、两个、三个甚至更多。使用在函数的形参上，相当于一个数组，调用函数时传递多少了实际参数，都可以存储到这个形参上。</p><p>在此代码段中也可以用数组表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTotalTax</span><span class="hljs-params">(Income[] incomes)</span>&#123;<br>        <span class="hljs-type">double</span> total=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Income income:incomes)&#123;<br>            total+=income.getTax();<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p></li><li><p>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</p></li><li><p>如果不实现抽象方法，则该子类仍是一个抽象类；</p></li><li><p>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</p></li></ul><hr><h3 id="8-接口"><a href="#8-接口" class="headerlink" title="8. 接口"></a>8. 接口</h3><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：<code>interface</code>。</p><p>在Java中，使用<code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p>当一个具体的class去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span>, Hello &#123; <span class="hljs-comment">// 实现了两个interface</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>注意区分术语：</p><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p><p>抽象类和接口的对比如下：</p><table><thead><tr><th></th><th>abstract class</th><th>interface</th></tr></thead><tbody><tr><td>继承</td><td>只能extends一个class</td><td>可以implements多个interface</td></tr><tr><td>字段</td><td>可以定义实例字段</td><td>不能定义实例字段</td></tr><tr><td>抽象方法</td><td>可以定义抽象方法</td><td>可以定义抽象方法</td></tr><tr><td>非抽象方法</td><td>可以定义非抽象方法</td><td>可以定义default方法</td></tr></tbody></table><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。</p><p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p><pre><code class="hljs">List list = new ArrayList(); // 用List接口引用具体子类的实例Collection coll = list; // 向上转型为Collection接口Iterable it = coll; // 向上转型为Iterable接口</code></pre><h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Mao&quot;</span>);<br>        p.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><p>用接口给一个有工资收入和稿费收入的小伙伴算税:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span><br>    &#123;<br>        Income[] incomes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Income</span>[] &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SalaryIncome</span>(<span class="hljs-number">8000</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoyaltyIncome</span>(<span class="hljs-number">12000</span>)<br>        &#125;;<br>        System.out.println(getTotalTax(incomes));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTotalTax</span><span class="hljs-params">(Income... incomes)</span>&#123;<br>        <span class="hljs-type">double</span> total=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Income income:incomes)&#123;<br>            total+=income.getTax();<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计税的抽象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span>  <span class="hljs-title class_">Income</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工资计税</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryIncome</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Income</span><br>&#123;<br>    <span class="hljs-type">double</span> income;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SalaryIncome</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.income=income;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.income &lt;= <span class="hljs-number">5000</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 稿费计税</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RoyaltyIncome</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Income</span><br>&#123;<br>    <span class="hljs-type">double</span> income;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RoyaltyIncome</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.income=income;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.income * <span class="hljs-number">0.1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li><p>Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；</p></li><li><p>接口也是数据类型，适用于向上转型和向下转型；</p></li><li><p>接口的所有方法都是抽象方法，接口不能定义实例字段；</p></li><li><p>接口可以定义default方法（JDK&gt;=1.8）。</p></li></ul><hr><h3 id="9-静态字段和静态方法"><a href="#9-静态字段和静态方法" class="headerlink" title="9. 静态字段和静态方法"></a>9. 静态字段和静态方法</h3><h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p><p>还有一种字段，是用static修饰的字段，称为静态字段：<code>static field</code>。</p><p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// 定义静态字段number:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> number;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">ming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">hong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Xiao Hong&quot;</span>, <span class="hljs-number">15</span>);<br>        ming.number = <span class="hljs-number">88</span>;<br>        System.out.println(hong.number);<br>        System.out.println(ming.number);<br>        hong.number = <span class="hljs-number">99</span>;<br>        System.out.println(ming.number);<br>        System.out.println(hong.number);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><pre><code class="hljs">88889999</code></pre><p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例。</p><p>虽然实例可以访问静态字段，但是它们指向的其实都是<code>Person class</code>的静态字段。所以，所有实例共享一个静态字段。</p><p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。</p><p>推荐用<code>类名</code>来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person.number = <span class="hljs-number">99</span>;<br>System.out.println(Person.number);<br></code></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>有静态字段，就有静态方法。用<code>static</code>修饰的方法称为静态方法。</p><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person.setNumber(<span class="hljs-number">99</span>);<br>        System.out.println(Person.number);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        number = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p><p>通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</p><p>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</p><p>静态方法经常用于工具类。例如：</p><ul><li><p>Arrays.sort()</p></li><li><p>Math.random()</p></li></ul><p>静态方法也经常用于辅助方法。注意到Java程序的入口<code>main()</code>也是静态方法。</p><h4 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h4><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FEMALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 编译器会自动加上public statc final:</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">MALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">FEMALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会自动把该字段变为<code>public static final</code>类型。</p><p>给Person类增加一个静态字段count和静态方法getCount，统计实例创建的个数,示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person p1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Mao&quot;</span>);<br>        Person p2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Zhang&quot;</span>);<br>        Person p3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Li&quot;</span>);<br>        System.out.println(Person.getCount());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul><li><p>静态字段属于所有实例“共享”的字段，实际上是属于class的字段；</p></li><li><p>调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法；</p></li><li><p>静态方法常用于工具类和辅助方法。</p></li></ul><h3 id="10-包"><a href="#10-包" class="headerlink" title="10. 包"></a>10. 包</h3><p>在前面的代码中，我们把类和接口命名为<code>Person</code>、<code>Student</code>、<code>Hello</code>等简单名字。</p><p>在现实中，如果小明写了一个<code>Person</code>类，小红也写了一个<code>Person</code>类，现在，小白既想用小明的<code>Person</code>，也想用小红的<code>Person</code>，怎么办？</p><p>如果小军写了一个<code>Arrays</code>类，恰好JDK也自带了一个<code>Arrays</code>类，如何解决类名冲突？</p><p>在Java中，我们使用<code>package</code>来解决名字冲突。</p><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是包名.类名。</p><p>例如：</p><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p><p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p><p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p><p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p><p>在定义class的时候，我们需要在第一行声明这个class属于哪个包。</p><p>小明的<code>Person.java</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ming; <span class="hljs-comment">// 申明包名ming</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>小军的<code>Arrays.java</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mr.jun; <span class="hljs-comment">// 申明包名mr.jun</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Arrays</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p><p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p><p><strong>要特别注意：包没有父子关系。<code>java.util</code>和<code>java.util.zip</code>是不同的包，两者没有任何继承关系。</strong></p><p>没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p><p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，<code>hong</code>、<code>ming</code>等应放在src下。</p><p>即所有Java文件对应的目录层次要和包的层次一致。</p><p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下</p><h4 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h4><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 包作用域:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Main</code>类也定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.hello(); <span class="hljs-comment">// 可以调用，因为Main和Person在同一个包</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法：</p><p>第一种，直接写出完整类名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        mr.jun.<span class="hljs-type">Arrays</span> <span class="hljs-variable">arrays</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">mr</span>.jun.Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入完整类名:</span><br><span class="hljs-keyword">import</span> mr.jun.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Arrays</span> <span class="hljs-variable">arrays</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arrays</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有class都导入进来（但不包括子包的class）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入mr.jun包的所有class:</span><br><span class="hljs-keyword">import</span> mr.jun.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Arrays</span> <span class="hljs-variable">arrays</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arrays</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p><p>Java编译器最终编译出的<code>.class</code>文件只使用完整类名，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><p>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</p><p>如果是简单类名，按下面的顺序依次查找：</p><p>查找当前<code>package</code>是否存在这个<code>class</code>；</p><p>查找<code>import</code>的包是否包含这个<code>class</code>；</p><p>查找<code>java.lang</code>包是否包含这个<code>class</code>。</p><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> java.text.Format;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        java.util.List list; <span class="hljs-comment">// ok，使用完整类名 -&gt; java.util.List</span><br>        <span class="hljs-type">Format</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// ok，使用import的类 -&gt; java.text.Format</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// ok，使用java.lang包的String -&gt; java.lang.String</span><br>        System.out.println(s); <span class="hljs-comment">// ok，使用java.lang包的System -&gt; java.lang.System</span><br>        <span class="hljs-type">MessageFormat</span> <span class="hljs-variable">mf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，编写class的时候，编译器会自动帮我们做两个<code>import</code>动作：</p><p>默认自动<code>import</code>当前package的其他class；</p><p>默认自动<code>import java.lang.*</code>。</p><blockquote><p><em><strong>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</strong></em></p></blockquote><p>如果有两个class名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample<br>子包就可以根据功能自行命名。</li></ul><p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p><ul><li>String</li><li>System</li><li>Runtime</li><li>…</li></ul><p>要注意也不要和JDK常用类重名：</p><ul><li>java.util.List</li><li>java.text.Format</li><li>java.math.BigInteger</li><li>…</li></ul><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><ul><li><p>Java内建的<code>package</code>机制是为了避免class命名冲突；</p></li><li><p>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</p></li><li><p>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p></li><li><p>包名推荐使用倒置的域名，例如<code>org.apache</code>。</p></li></ul><hr><h3 id="11-作用域"><a href="#11-作用域" class="headerlink" title="11. 作用域"></a>11. 作用域</h3><p>在Java中，我们经常看到<code>public</code>、<code>protected</code>、<code>private</code>这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Main可以访问Hello</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-comment">// 不能被其他类调用:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>确切地说，<code>private</code>访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.hi();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        i.hi();<br>    &#125;<br><br>    <span class="hljs-comment">// private方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;private hello!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 静态内部类:</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>            Main.hello();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义在一个class内部的class称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p><h4 id="protected-1"><a href="#protected-1" class="headerlink" title="protected"></a>protected</h4><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-comment">// protected方法:</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>protected</code>方法可以被继承的类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问protected方法:</span><br>        hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>最后，包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><span class="hljs-comment">// package权限的类:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-comment">// package权限的方法:</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问package权限的类:</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>();<br>        <span class="hljs-comment">// 可以调用package权限的方法:</span><br>        h.hi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(String name)</span> &#123; <span class="hljs-comment">// ①</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> name.toLowerCase(); <span class="hljs-comment">// ②</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length(); <span class="hljs-comment">// ③</span><br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// ④</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> - len; <span class="hljs-comment">// ⑤</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <span class="hljs-comment">// ⑥</span><br>                System.out.println(); <span class="hljs-comment">// ⑦</span><br>            &#125; <span class="hljs-comment">// ⑧</span><br>        &#125; <span class="hljs-comment">// ⑨</span><br>    &#125; <span class="hljs-comment">// ⑩</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们观察上面的hi()方法代码：</p><ul><li><p>方法参数name是局部变量，它的作用域是整个方法，即①～⑩；</p></li><li><p>变量s的作用域是定义处到方法结束，即②～⑩；</p></li><li><p>变量len的作用域是定义处到方法结束，即③～⑩；</p></li><li><p>变量p的作用域是定义处到if块结束，即⑤～⑨；</p></li><li><p>变量i的作用域是for循环，即⑥～⑧。</p></li></ul><p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p><h4 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h4><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-comment">// 无法被继承:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-comment">// 无法被覆写:</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>局部变量</code>可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> t)</span> &#123;<br>        t = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个<code>非public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><ul><li><p>Java内建的访问权限包括public、protected、private和package权限；</p></li><li><p>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</p></li><li><p>final修饰符不是访问权限，它可以修饰class、field和method；</p></li><li><p>一个.java文件只能包含一个public类，但可以包含多个非public类。</p></li></ul><h3 id="12-内部类"><a href="#12-内部类" class="headerlink" title="12. 内部类"></a>12. 内部类</h3><p>还有一种类，它被定义在另一个类的内部，所以称为内部类（<code>Nested Class</code>）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。</p><h4 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a>Inner Class</h4><p>如果一个类定义在另一个类的内部，这个类就是<code>Inner Class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-comment">// 定义了一个Inner Class</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述定义的<code>Outer</code>是一个普通类，而<code>Inner</code>是一个<code>Inner Class</code>，它与普通类有个最大的不同，就是<code>Inner Class</code>的实例不能单独存在，必须依附于一个<code>Outer Class</code>的实例。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(<span class="hljs-string">&quot;Nested&quot;</span>); <span class="hljs-comment">// 实例化一个Outer</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">// 实例化一个Inner</span><br>        inner.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-built_in">this</span>.name);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为<code>Inner Class</code>除了有一个this指向它自己，还隐含地持有一个<code>Outer Class</code>实例，可以用<code>Outer.this</code>访问这个实例。所以，实例化一个<code>Inner Class</code>不能脱离<code>Outer</code>实例。</p><p><code>Inner Class</code>和普通<code>Class</code>相比，除了能引用<code>Outer</code>实例外，还有一个额外的“特权”，就是可以修改<code>Outer Class</code>的<code>private</code>字段，因为<code>Inner Class</code>的作用域在<code>Outer Class</code>内部，所以能访问<code>Outer Class</code>的<code>private</code>字段和方法。</p><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。</p><h4 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h4><p>还有一种定义<code>Inner Class</code>的方法，它不需要在<code>Outer Class</code>中明确地定义这个Class，而是在方法内部，通过匿名类（<code>Anonymous Class</code>）来定义。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(<span class="hljs-string">&quot;Nested&quot;</span>);<br>        outer.asyncHello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.<span class="hljs-built_in">this</span>.name);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable。Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-comment">// 实现必要的抽象方法...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>匿名类和<code>Inner Class</code>一样，可以访问<code>Outer Class</code>的<code>private</code>字段和方法。</p><blockquote><p>使用匿名内部类还有个前提条件：<em><strong>必须继承一个父类或实现一个接口</strong></em></p></blockquote><p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        HashMap&lt;String, String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;String, String&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="hljs-comment">// 匿名类!</span><br>        HashMap&lt;String, String&gt; map3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;<br>            &#123;<br>                put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>                put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>            &#125;<br>        &#125;;<br>        System.out.println(map3.get(<span class="hljs-string">&quot;A&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map1</code>是一个普通的<code>HashMap</code>实例，但<code>map2</code>是一个匿名类实例，只是该匿名类继承自<code>HashMap</code>。<code>map3</code>也是一个继承自<code>HashMap</code>的匿名类实例，并且添加了<code>static</code>代码块来初始化数据。观察编译输出可发现<code>Main$1.class</code>和<code>Main$2.class</code>两个匿名类文件。</p><h4 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h4><p>最后一种内部类和<code>Inner Class</code>类似，但是使用<code>static</code>修饰，称为静态内部类（<code>Static Nested Class</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Outer.<span class="hljs-type">StaticNested</span> <span class="hljs-variable">sn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.StaticNested();<br>        sn.hello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OUTER&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    Outer(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticNested</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + Outer.NAME);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>static</code>修饰的内部类和<code>Inner Class</code>有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><ul><li><p>Java的内部类可分为<code>Inner Class</code>、<code>Anonymous Class</code>和<code>Static Nested Class</code>三种：</p></li><li><p><code>Inner Class</code>和<code>Anonymous Class</code>本质上是相同的，都必须依附于<code>Outer Class</code>的实例，即隐含地持有<code>Outer.this</code>实例，并拥有<code>Outer Class</code>的<code>private</code>访问权限；</p></li><li><p><code>Static Nested Class</code>是独立类，但拥有<code>Outer Class</code>的<code>private</code>访问权限。</p></li></ul><h2 id="二、JAVA核心类"><a href="#二、JAVA核心类" class="headerlink" title="二、JAVA核心类"></a>二、JAVA核心类</h2><p>本节介绍Java的核心类，包括：</p><ul><li><p>字符串</p></li><li><p>StringBuilder</p></li><li><p>StringJoiner</p></li><li><p>包装类型</p></li><li><p>JavaBean</p></li><li><p>枚举</p></li><li><p>常用工具类</p></li></ul><h3 id="1-字符串和编码"><a href="#1-字符串和编码" class="headerlink" title="1. 字符串和编码"></a>1. 字符串和编码</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p><pre><code class="hljs">String s1 = &quot;Hello!&quot;;</code></pre><p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><pre><code class="hljs">String s2 = new String(new char[] &#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;&#125;);</code></pre><p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p><p>Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p><pre><code class="hljs">System.out.println(s1.equals(s2));</code></pre><p>两个字符串比较，必须总是使用<code>equals()</code>方法。</p><p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p><p>String类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 是否包含子串:</span><br><span class="hljs-string">&quot;Hello&quot;</span>.contains(<span class="hljs-string">&quot;ll&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>的父类。</p><p>搜索子串的更多的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;Hello&quot;</span>.indexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-string">&quot;Hello&quot;</span>.lastIndexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-string">&quot;Hello&quot;</span>.startsWith(<span class="hljs-string">&quot;He&quot;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-string">&quot;Hello&quot;</span>.endsWith(<span class="hljs-string">&quot;lo&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>提取子串的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;Hello&quot;</span>.substring(<span class="hljs-number">2</span>); <span class="hljs-comment">// &quot;llo&quot;</span><br><span class="hljs-string">&quot;Hello&quot;</span>.substring(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//&quot;ll&quot;</span><br></code></pre></td></tr></table></figure><p>注意索引号是从0开始的。</p><h4 id="去除首尾空白字符"><a href="#去除首尾空白字符" class="headerlink" title="去除首尾空白字符"></a>去除首尾空白字符</h4><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="hljs-comment">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="hljs-comment">// &quot;Hello&quot;</span><br><span class="hljs-string">&quot; Hello &quot;</span>.stripLeading(); <span class="hljs-comment">// &quot;Hello &quot;</span><br><span class="hljs-string">&quot; Hello &quot;</span>.stripTrailing(); <span class="hljs-comment">// &quot; Hello&quot;</span><br></code></pre></td></tr></table></figure><p>String还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;&quot;</span>.isEmpty(); <span class="hljs-comment">// true，因为字符串长度为0</span><br><span class="hljs-string">&quot;  &quot;</span>.isEmpty(); <span class="hljs-comment">// false，因为字符串长度不为0</span><br><span class="hljs-string">&quot;  \n&quot;</span>.isBlank(); <span class="hljs-comment">// true，因为只包含空白字符</span><br><span class="hljs-string">&quot; Hello &quot;</span>.isBlank(); <span class="hljs-comment">// false，因为包含非空白字符</span><br></code></pre></td></tr></table></figure><h4 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h4><p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>s.replace(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>); <span class="hljs-comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span><br>s.replace(<span class="hljs-string">&quot;ll&quot;</span>, <span class="hljs-string">&quot;~~&quot;</span>); <span class="hljs-comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span><br></code></pre></td></tr></table></figure><p>另一种是通过正则表达式替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A,,B;C ,D&quot;</span>;<br>s.replaceAll(<span class="hljs-string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">// &quot;A,B,C,D&quot;</span><br></code></pre></td></tr></table></figure><p>上面的代码通过正则表达式，把匹配的子串统一替换为”,”。关于正则表达式的用法我们会在后面详细讲解。</p><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A,B,C,D&quot;</span>;<br>String[] ss = s.split(<span class="hljs-string">&quot;\\,&quot;</span>); <span class="hljs-comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>EG 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;ABCD&quot;</span>;<br>String[] ss = s.split(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;***&quot;</span>, arr); <span class="hljs-comment">// &quot;A***B***C&quot;</span><br></code></pre></td></tr></table></figure><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hi %s, your score is %d!&quot;</span>;<br>        System.out.println(s.formatted(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">80</span>));<br>        System.out.println(String.format(<span class="hljs-string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">59.5</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p><ul><li><code>%s：</code>显示字符串；</li><li><code>%d：</code>显示整数；</li><li><code>%x：</code>显示十六进制整数；</li><li><code>%f：</code>显示浮点数。</li></ul><p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用%s，因为<code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a>。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String.valueOf(<span class="hljs-number">123</span>); <span class="hljs-comment">// &quot;123&quot;</span><br>String.valueOf(<span class="hljs-number">45.67</span>); <span class="hljs-comment">// &quot;45.67&quot;</span><br>String.valueOf(<span class="hljs-literal">true</span>); <span class="hljs-comment">// &quot;true&quot;</span><br>String.valueOf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()); <span class="hljs-comment">// 类似java.lang.Object@636be97c</span><br></code></pre></td></tr></table></figure><p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 123</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;ff&quot;</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// 按十六进制转换，255</span><br></code></pre></td></tr></table></figure><p>把字符串转换为<code>boolean</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(<span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(<span class="hljs-string">&quot;FALSE&quot;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.getInteger(<span class="hljs-string">&quot;java.version&quot;</span>); <span class="hljs-comment">// 版本号，11</span><br></code></pre></td></tr></table></figure><h4 id="转换为char"><a href="#转换为char" class="headerlink" title="转换为char[]"></a>转换为char[]</h4><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] cs = <span class="hljs-string">&quot;Hello&quot;</span>.toCharArray(); <span class="hljs-comment">// String -&gt; char[]</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cs); <span class="hljs-comment">// char[] -&gt; String</span><br></code></pre></td></tr></table></figure><p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = <span class="hljs-string">&quot;Hello&quot;</span>.toCharArray();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cs);<br>        System.out.println(s);<br>        cs[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为通过<code>new String(char[])</code>创建新的String实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p><p>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p><p>例,设计了一个Score类保存一组学生的成绩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">88</span>, <span class="hljs-number">77</span>, <span class="hljs-number">51</span>, <span class="hljs-number">66</span> &#125;;<br>        <span class="hljs-type">Score</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>(scores);<br>        s.printScores();<br>        scores[<span class="hljs-number">2</span>] = <span class="hljs-number">99</span>;<br>        s.printScores();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] scores;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(<span class="hljs-type">int</span>[] scores)</span> &#123;<br>        <span class="hljs-built_in">this</span>.scores = scores;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printScores</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Arrays.toString(<span class="hljs-built_in">this</span>.scores));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察两次输出，由于<code>Score</code>内部直接引用了外部传入的<code>int[]</code>数组，这会造成外部代码对<code>int[]</code>数组的修改，影响到<code>Score</code>类的字段。如果外部代码不可信，这就会造成安全隐患。</p><p>请修复<code>Score</code>的构造方法，使得外部代码对数组的修改不影响<code>Score</code>实例的int[]字段。</p><pre><code class="hljs">this.scores = scores.clone();</code></pre><p>整体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">88</span>, <span class="hljs-number">77</span>, <span class="hljs-number">51</span>, <span class="hljs-number">66</span> &#125;;<br>        <span class="hljs-type">Score</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>(scores);<br>        s.printScores();<br>        scores[<span class="hljs-number">2</span>] = <span class="hljs-number">99</span>;<br>        s.printScores();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] scores;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(<span class="hljs-type">int</span>[] scores)</span> &#123;<br>        <span class="hljs-built_in">this</span>.scores = scores.clone();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printScores</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Arrays.toString(<span class="hljs-built_in">this</span>.scores));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] b1 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(); <span class="hljs-comment">// 按系统默认编码转换，不推荐</span><br><span class="hljs-type">byte</span>[] b2 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>); <span class="hljs-comment">// 按UTF-8编码转换</span><br><span class="hljs-type">byte</span>[] b2 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 按GBK编码转换</span><br><span class="hljs-type">byte</span>[] b3 = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8编码转换</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：转换编码后，就不再是char类型，而是byte类型表示的数组。</p></blockquote><p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] b = ...<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">// 按GBK转换</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8转换</span><br></code></pre></td></tr></table></figure><blockquote><p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以<code>Unicode</code>编码表示。</p></blockquote><h4 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h4><ul><li><p>Java字符串<code>String</code>是不可变对象；</p></li><li><p>字符串操作不改变原字符串内容，而是返回新字符串；</p></li><li><p>常用的字符串操作：提取子串、查找、替换、大小写转换等；</p></li><li><p>Java使用<code>Unicode</code>编码表示<code>String</code>和<code>char</code>；</p></li><li><p>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</p></li><li><p>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</p></li></ul><h3 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2. StringBuilder"></a>2. StringBuilder</h3><h4 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h4><p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用+拼接字符串。</p><p>考察下面的循环代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    s = s + <span class="hljs-string">&quot;,&quot;</span> + i;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>    sb.append(i);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sb.toString();<br></code></pre></td></tr></table></figure><p><code>StringBuilder</code>还可以进行链式操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">1024</span>);<br>        sb.append(<span class="hljs-string">&quot;Mr &quot;</span>)<br>          .append(<span class="hljs-string">&quot;Bob&quot;</span>)<br>          .append(<span class="hljs-string">&quot;!&quot;</span>)<br>          .insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Hello, &quot;</span>);<br>        System.out.println(sb.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们查看<code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法。</p><p>仿照<code>StringBuilder</code>，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Adder</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adder</span>();<br>        adder.add(<span class="hljs-number">3</span>)<br>             .add(<span class="hljs-number">5</span>)<br>             .inc()<br>             .add(<span class="hljs-number">10</span>);<br>        System.out.println(adder.value());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> Adder <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        sum += n;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Adder <span class="hljs-title function_">inc</span><span class="hljs-params">()</span> &#123;<br>        sum ++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：对于普通的字符串+操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的+操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者`StringBuilder``操作。</p></blockquote><p>你可能还听说过<code>StringBuffer</code>，这是<code>Java早期的一个</code>StringBuilder<code>的线程安全版本，它通过同步来保证多个线程操作</code>StringBuffer`也是安全的，但是同步会带来执行速度的下降。</p><p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p><p>使用<code>StringBuilder</code>构造一个<code>INSERT</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] fields = &#123; <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;position&quot;</span>, <span class="hljs-string">&quot;salary&quot;</span> &#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;employee&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">insert</span> <span class="hljs-operator">=</span> buildInsertSql(table, fields);<br>        System.out.println(insert);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)&quot;</span>;<br>        System.out.println(s.equals(insert) ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">buildInsertSql</span><span class="hljs-params">(String table, String[] fields)</span> &#123;<br>        StringBuffer Insert=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-number">1024</span>);<br>        Insert.append(<span class="hljs-string">&quot;INSERT INTO &quot;</span>)<br>                .append(table)<br>                .append(<span class="hljs-string">&quot; (&quot;</span>)<br>                .append(String.join(<span class="hljs-string">&quot;, &quot;</span>, fields))<br>                .append(<span class="hljs-string">&quot;) VALUES (?, ?, ?)&quot;</span>);<br>        <span class="hljs-keyword">return</span> Insert.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h4><ul><li><p><code>StringBuilder</code>是可变对象，用来高效拼接字符串；</p></li><li><p><code>StringBuilder</code>可以支持链式操作，实现链式操作的关键是返回实例本身；</p></li><li><p><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，现在很少使用。</p></li></ul><h3 id="3-StringJoiner"><a href="#3-StringJoiner" class="headerlink" title="3. StringJoiner"></a>3. StringJoiner</h3><h4 id="StringJoiner用法"><a href="#StringJoiner用法" class="headerlink" title="StringJoiner用法"></a>StringJoiner用法</h4><p>要高效拼接字符串，应该使用<code>StringBuilder</code>。</p><p>很多时候，我们拼接的字符串像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] names = &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Grace&quot;</span>&#125;;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&quot;Hello &quot;</span>);<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            sb.append(name).append(<span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 注意去掉最后的&quot;, &quot;:</span><br>        sb.delete(sb.length() - <span class="hljs-number">2</span>, sb.length());<br>        sb.append(<span class="hljs-string">&quot;!&quot;</span>);<br>        System.out.println(sb.toString());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] names = &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Grace&quot;</span>&#125;;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>);<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            sj.add(name);<br>        &#125;<br>        System.out.println(sj.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>StringJoiner</code>的结果少了前面的<code>&quot;Hello &quot;</code>和结尾的<code>&quot;!&quot;！</code>遇到这种情况，需要给<code>StringJoiner</code>指定“开头”和“结尾”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] names = &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Grace&quot;</span>&#125;;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;Hello &quot;</span>, <span class="hljs-string">&quot;!&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            sj.add(name);<br>        &#125;<br>        System.out.println(sj.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="String-join"><a href="#String-join" class="headerlink" title="String.join()"></a>String.join()</h4><p>String还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] names = &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Grace&quot;</span>&#125;;<br><span class="hljs-type">var</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;, &quot;</span>, names);<br></code></pre></td></tr></table></figure><p>使用<code>StringJoiner</code>构造一个<code>SELECT</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.StringJoiner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] fields = &#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;position&quot;</span>, <span class="hljs-string">&quot;salary&quot;</span>&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;employee&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">select</span> <span class="hljs-operator">=</span> buildSelectSql(table, fields);<br>        System.out.println(select);<br>        System.out.println(<span class="hljs-string">&quot;SELECT name, position, salary FROM employee&quot;</span>.equals(select) ? <span class="hljs-string">&quot;测试成功&quot;</span> : <span class="hljs-string">&quot;测试失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">buildSelectSql</span><span class="hljs-params">(String table, String[] fields)</span> &#123;<br>        <span class="hljs-keyword">var</span> s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>,<span class="hljs-string">&quot;SELECT &quot;</span>,<span class="hljs-string">&quot; FROM &quot;</span>+table);<br>        <span class="hljs-keyword">for</span>(String field:fields)&#123;<br>            s.add(field);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h4><ul><li><p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p></li><li><p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档</tag>
      
      <tag>基础</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法</title>
    <link href="/2022/10/31/MarkDown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/10/31/MarkDown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown-基础语法"><a href="#MarkDown-基础语法" class="headerlink" title="MarkDown 基础语法"></a>MarkDown 基础语法</h1><h2 id="1-Markdown-标题"><a href="#1-Markdown-标题" class="headerlink" title="1. Markdown 标题"></a>1. Markdown 标题</h2><p>要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 (<code>&lt;h3&gt;</code>) (例如：<code>### My Header</code>)。</p><hr><h2 id="2-Markdown-段落"><a href="#2-Markdown-段落" class="headerlink" title="2. Markdown 段落"></a>2. Markdown 段落</h2><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p><hr><h2 id="3-Markdown-换行"><a href="#3-Markdown-换行" class="headerlink" title="3. Markdown 换行"></a>3. Markdown 换行</h2><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)。</p><hr><h2 id="4-Markdown-强调"><a href="#4-Markdown-强调" class="headerlink" title="4. Markdown 强调"></a>4. Markdown 强调</h2><h3 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。\</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">I <span class="hljs-keyword">just </span>love **<span class="hljs-keyword">bold </span>text**.<br></code></pre></td></tr></table></figure><p> I just love <strong>bold text</strong>.</p><h3 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。\</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Italicized <span class="hljs-keyword">text</span> <span class="hljs-built_in">is</span> the *cat<span class="hljs-comment">&#x27;s meow*.</span><br></code></pre></td></tr></table></figure><p>Italicized text is the <em>cat’s meow</em>.</p><h3 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="粗体（Bold）和斜体（Italic）"></a>粗体（Bold）和斜体（Italic）</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。\</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">This <span class="hljs-built_in">text</span> <span class="hljs-keyword">is</span> ***really important***.<br></code></pre></td></tr></table></figure><p>This text is <em><strong>really important</strong></em>.</p><hr><h2 id="5-Markdown-引用"><a href="#5-Markdown-引用" class="headerlink" title="5. Markdown 引用"></a>5. Markdown 引用</h2><p>要创建块引用，请在段落前添加一个 &gt; 符号。\</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Dorothy</span> followed her through many <span class="hljs-keyword">of</span> the beautiful rooms <span class="hljs-keyword">in</span> her castle.</span><br></code></pre></td></tr></table></figure><p>效果如下:</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><h3 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h3><p>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Dorothy</span> followed her through many <span class="hljs-keyword">of</span> the beautiful rooms <span class="hljs-keyword">in</span> her castle.&gt;</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">The</span> <span class="hljs-title class_">Witch</span> bade her clean the pots and kettles and sweep the floor and keep the fire fed <span class="hljs-keyword">with</span> wood.</span><br></code></pre></td></tr></table></figure><p>效果如下:</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">&gt; Dorothy followed her through many of the <span class="hljs-keyword">beautiful </span>rooms in her castle.<br>&gt;<br>&gt;&gt; The Witch <span class="hljs-keyword">bade </span>her clean the pots <span class="hljs-keyword">and </span>kettles <span class="hljs-keyword">and </span><span class="hljs-keyword">sweep </span>the floor <span class="hljs-keyword">and </span>keep the fire fed with wood.<br></code></pre></td></tr></table></figure><p>效果如下:</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote></blockquote><h3 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="带有其它元素的块引用"></a>带有其它元素的块引用</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">#### <span class="hljs-title class_">The</span> quarterly results look great!</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Revenue</span> was off the chart.</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Profits</span> were higher than ever.</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"> *<span class="hljs-title class_">Everything</span>* is going according to **plan**.</span><br></code></pre></td></tr></table></figure><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.(-)</li><li>Profits were higher than ever.(-)</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><hr><h2 id="6-Markdown-列表"><a href="#6-Markdown-列表" class="headerlink" title="6. Markdown 列表"></a>6. Markdown 列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span> First <span class="hljs-built_in">item</span><br><span class="hljs-number">2.</span> Second <span class="hljs-built_in">item</span><br><span class="hljs-number">3.</span> Third <span class="hljs-built_in">item</span><br><span class="hljs-number">4.</span> Fourth <span class="hljs-built_in">item</span><br></code></pre></td></tr></table></figure><ol><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">- First <span class="hljs-built_in">item</span><br>- Second <span class="hljs-built_in">item</span><br>- Third <span class="hljs-built_in">item</span><br>- Fourth <span class="hljs-built_in">item</span><br></code></pre></td></tr></table></figure><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item<h3 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h3>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">*   This <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br>*   Here&#x27;s <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br><br>    I need <span class="hljs-keyword">to</span> add another <span class="hljs-built_in">paragraph</span> <span class="hljs-keyword">below</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br><br>*   And here&#x27;s <span class="hljs-keyword">the</span> <span class="hljs-keyword">third</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br></code></pre></td></tr></table></figure><ul><li><p>  This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>  I need to add another paragraph below the second list item.</p></li><li><p>  And here’s the third list item.</p></li></ul><h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">*   This <span class="hljs-keyword">is</span> the first list item.<br>*   Her<span class="hljs-string">e&#x27;s the second list item.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt; A blockquote would look great below the second list item.</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   And here&#x27;</span>s the third list item.<br></code></pre></td></tr></table></figure><ul><li><p>  This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>  And here’s the third list item.</p></li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.  Open the <span class="hljs-keyword">file</span>.<br><span class="hljs-number">2</span>.  Find the following code block <span class="hljs-keyword">on</span> <span class="hljs-built_in">line</span> <span class="hljs-number">21</span>:<br>        <span class="hljs-symbol">&lt;html&gt;</span><br>          <span class="hljs-symbol">&lt;head&gt;</span><br>            <span class="hljs-symbol">&lt;title&gt;</span>Test&lt;/title&gt;<br>          &lt;/head&gt;<br><span class="hljs-number">3</span>.  Update the title <span class="hljs-keyword">to</span> <span class="hljs-keyword">match</span> the name of your website.<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.  Open the <span class="hljs-keyword">file</span>.<br><span class="hljs-number">2</span>.  Find the following code block <span class="hljs-keyword">on</span> <span class="hljs-built_in">line</span> <span class="hljs-number">21</span>:<br>    ```html<br>        <span class="hljs-symbol">&lt;html&gt;</span><br>            <span class="hljs-symbol">&lt;head&gt;</span><br>            <span class="hljs-symbol">&lt;title&gt;</span>Test&lt;/title&gt;<br>            &lt;/head&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li> Update the title to match the name of your website.<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">效果如下：<br><span class="hljs-number">1</span>.  Open the <span class="hljs-keyword">file</span>.<br><span class="hljs-number">2</span>.  Find the following code block <span class="hljs-keyword">on</span> <span class="hljs-built_in">line</span> <span class="hljs-number">21</span>:<br>    ```html<br>        <span class="hljs-symbol">&lt;html&gt;</span><br>            <span class="hljs-symbol">&lt;head&gt;</span><br>            <span class="hljs-symbol">&lt;title&gt;</span>Test&lt;/title&gt;<br>            &lt;/head&gt;<br></code></pre></td></tr></table></figure></li><li> Update the title to match the name of your website.<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4></li></ol><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas">1.  Open the <span class="hljs-keyword">file</span> containing the Linux mascot.<br>2.  Marvel at its beauty.<br><br>    ![Tux, the Linux mascot](https://www.bing.com/th?id=OSK.b15146a8bebfb993c6dad4725c884d6d<span class="hljs-variable">&amp;w</span>=148<span class="hljs-variable">&amp;h</span>=148<span class="hljs-variable">&amp;c</span>=7<span class="hljs-variable">&amp;o</span>=6<span class="hljs-variable">&amp;pid</span>=SANGAM)<br><br>3.  Close the <span class="hljs-keyword">file</span>.<br></code></pre></td></tr></table></figure><ol><li><p> Open the file containing the Linux mascot.</p></li><li><p>Marvel at its beauty.</p><p> <img src="https://www.bing.com/th?id=OSK.b15146a8bebfb993c6dad4725c884d6d&w=148&h=148&c=7&o=6&pid=SANGAM" alt="Tux, the Linux mascot"></p></li><li><p> Close the file.</p></li></ol><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span> First <span class="hljs-built_in">item</span><br><span class="hljs-number">2.</span> Second <span class="hljs-built_in">item</span><br><span class="hljs-number">3.</span> Third <span class="hljs-built_in">item</span><br>    - Indented <span class="hljs-built_in">item</span><br>    - Indented <span class="hljs-built_in">item</span><br><span class="hljs-number">4.</span> Fourth <span class="hljs-built_in">item</span><br></code></pre></td></tr></table></figure><ol><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ol><hr><h2 id="7-Markdown-代码"><a href="#7-Markdown-代码" class="headerlink" title="7. Markdown 代码"></a>7. Markdown 代码</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</p><p>At the command prompt, type <code>nano</code>.</p><h3 id="Markdown-围栏代码块"><a href="#Markdown-围栏代码块" class="headerlink" title="Markdown 围栏代码块"></a>Markdown 围栏代码块</h3><p>Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁边指定一种语言。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="8-Markdown-分隔线语法"><a href="#8-Markdown-分隔线语法" class="headerlink" title="8. Markdown 分隔线语法"></a>8. Markdown 分隔线语法</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。\</p><pre><code class="hljs">---***_________________</code></pre><hr><h2 id="9-Markdown-链接语法"><a href="#9-Markdown-链接语法" class="headerlink" title="9. Markdown 链接语法"></a>9. Markdown 链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p><p>超链接Markdown语法代码：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-name">超链接显示名</span>](<span class="hljs-name">超链接地址</span> <span class="hljs-string">&quot;超链接title&quot;</span>)<br></code></pre></td></tr></table></figure><p>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code></p><p>这是一个链接 <a href="https://markdown.com.cn/">Markdown语法</a>。</p><h3 id="给链接增加-Title"><a href="#给链接增加-Title" class="headerlink" title="给链接增加 Title"></a>给链接增加 Title</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。\</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">这是一个链接 [Markdown语法](https:<span class="hljs-regexp">//m</span>arkdown.com.cn <span class="hljs-string">&quot;最好的markdown教程&quot;</span>)。<br></code></pre></td></tr></table></figure><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><h3 id="网址和Email地址"><a href="#网址和Email地址" class="headerlink" title="网址和Email地址"></a>网址和Email地址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">&lt;https://markdown.<span class="hljs-keyword">com</span>.<span class="hljs-keyword">cn</span>&gt;<br>&lt;fake@example.<span class="hljs-keyword">com</span>&gt;<br></code></pre></td></tr></table></figure><p><a href="https://markdown.com.cn/">https://markdown.com.cn</a><br><a href="mailto:&#102;&#x61;&#x6b;&#x65;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#102;&#x61;&#x6b;&#x65;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109;</a></p><h3 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h3><p>强调 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">I love supporting the <span class="hljs-strong">**[<span class="hljs-string">EFF</span>](<span class="hljs-link">https://eff.org</span>)**</span>.<br>This is the <span class="hljs-emphasis">*[<span class="hljs-string">Markdown Guide</span>](<span class="hljs-link">https://www.markdownguide.org</span>)*</span>.<br>See the section on [<span class="hljs-string">`code`</span>](<span class="hljs-link">#code</span>).<br></code></pre></td></tr></table></figure><p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p><h3 id="引用类型链接"><a href="#引用类型链接" class="headerlink" title="引用类型链接"></a>引用类型链接</h3><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p><h3 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h3><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">- <span class="hljs-selector-attr">[hobbit-hole]</span><span class="hljs-selector-attr">[1]</span><br>- <span class="hljs-selector-attr">[hobbit-hole]</span> <span class="hljs-selector-attr">[1]</span><br></code></pre></td></tr></table></figure><h3 id="链接的第二部分格式"><a href="#链接的第二部分格式" class="headerlink" title="链接的第二部分格式"></a>链接的第二部分格式</h3><p>引用类型链接的第二部分使用以下属性设置格式：</p><ol><li>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。</li><li>链接的URL，可以选择将其括在尖括号中。</li><li>链接的可选标题，可以将其括在双引号，单引号或括号中。</li></ol><p>以下示例格式对于链接的第二部分效果相同：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">* `[<span class="hljs-number">1</span>]: https:<span class="hljs-regexp">//</span>en.wikipedia.org<span class="hljs-regexp">/wiki/</span>Hobbit<span class="hljs-comment">#Lifestyle`</span><br>* `[<span class="hljs-number">1</span>]: https:<span class="hljs-regexp">//</span>en.wikipedia.org<span class="hljs-regexp">/wiki/</span>Hobbit<span class="hljs-comment">#Lifestyle &quot;Hobbit lifestyles&quot;`</span><br>* `[<span class="hljs-number">1</span>]: https:<span class="hljs-regexp">//</span>en.wikipedia.org<span class="hljs-regexp">/wiki/</span>Hobbit<span class="hljs-comment">#Lifestyle &#x27;Hobbit lifestyles&#x27;`</span><br>* `[<span class="hljs-number">1</span>]: https:<span class="hljs-regexp">//</span>en.wikipedia.org<span class="hljs-regexp">/wiki/</span>Hobbit<span class="hljs-comment">#Lifestyle (Hobbit lifestyles)`</span><br>* `[<span class="hljs-number">1</span>]: &lt;https:<span class="hljs-regexp">//</span>en.wikipedia.org<span class="hljs-regexp">/wiki/</span>Hobbit<span class="hljs-comment">#Lifestyle&gt; &quot;Hobbit lifestyles&quot;`</span><br>* `[<span class="hljs-number">1</span>]: &lt;https:<span class="hljs-regexp">//</span>en.wikipedia.org<span class="hljs-regexp">/wiki/</span>Hobbit<span class="hljs-comment">#Lifestyle&gt; &#x27;Hobbit lifestyles&#x27;`</span><br>* `[<span class="hljs-number">1</span>]: &lt;https:<span class="hljs-regexp">//</span>en.wikipedia.org<span class="hljs-regexp">/wiki/</span>Hobbit<span class="hljs-comment">#Lifestyle&gt; (Hobbit lifestyles)`</span><br></code></pre></td></tr></table></figure><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。</p><hr><h2 id="10-Markdown-图片"><a href="#10-Markdown-图片" class="headerlink" title="10. Markdown 图片"></a>10. Markdown 图片</h2><p>要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">![图片alt](图片链接 <span class="hljs-string">&quot;图片title&quot;</span>)。<br></code></pre></td></tr></table></figure><p>对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">![这是图片]<span class="hljs-params">(https://th.bing.com/th/id/OIP.SH8aY58n5xc4C30JDo-_agHaE8?<span class="hljs-attr">w</span>=270&amp;<span class="hljs-attr">h</span>=180&amp;<span class="hljs-attr">c</span>=7&amp;<span class="hljs-attr">r</span>=0&amp;<span class="hljs-attr">o</span>=5&amp;<span class="hljs-attr">pid</span>=1.7 &quot;Magic Gardens&quot;)</span><br></code></pre></td></tr></table></figure><p><img src="https://markdown.com.cn/assets/img/philly-magic-garden.9c0b4415.jpg" alt="这是图片" title="Magic Gardens"></p><h3 id="链接图片"><a href="#链接图片" class="headerlink" title="链接图片"></a>链接图片</h3><p>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-name">!</span>[<span class="hljs-name">沙漠中的岩石图片</span>](<span class="hljs-name">https://markdown.com.cn/assets/img/shiprock.c3b9a023.jpg</span> <span class="hljs-string">&quot;Shiprock&quot;</span>)](<span class="hljs-name">https://markdown.com.cn</span>)<br></code></pre></td></tr></table></figure><p><a href="https://markdown.com.cn/"><img src="https://markdown.com.cn/assets/img/shiprock.c3b9a023.jpg" alt="沙漠中的岩石图片" title="Shiprock"></a></p><hr><h2 id="11-Markdown-转义字符语法"><a href="#11-Markdown-转义字符语法" class="headerlink" title="11. Markdown 转义字符语法"></a>11. Markdown 转义字符语法</h2><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">\* Without <span class="hljs-keyword">the</span> <span class="hljs-literal">backslash</span>, this would be <span class="hljs-keyword">a</span> bullet <span class="hljs-keyword">in</span> <span class="hljs-keyword">an</span> unordered list.<br></code></pre></td></tr></table></figure><p>* Without the backslash, this would be a bullet in an unordered list.</p><h3 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h3><table><thead><tr><th>Character</th><th>Name</th></tr></thead><tbody><tr><td>\</td><td>backslash</td></tr><tr><td>`</td><td>backtick (see also escaping backticks in code)</td></tr><tr><td>*</td><td>asterisk</td></tr><tr><td>_</td><td>underscore</td></tr><tr><td>{ }</td><td>curly braces</td></tr><tr><td>[ ]</td><td>brackets</td></tr><tr><td>( )</td><td>parentheses</td></tr><tr><td>#</td><td>pound sign</td></tr><tr><td>+</td><td>plus sign</td></tr><tr><td>-</td><td>minus sign (hyphen)</td></tr><tr><td>.</td><td>dot</td></tr><tr><td>!</td><td>exclamation mark</td></tr><tr><td>|</td><td>pipe (see also escaping pipe in tables)</td></tr></tbody></table><h3 id="特殊字符自动转义"><a href="#特殊字符自动转义" class="headerlink" title="特殊字符自动转义"></a>特殊字符自动转义</h3><p>在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 &lt; 和 &amp;。</p><p>&amp; 符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;T」 ，还得转换网址内的 &amp; 符号，如果你要链接到：</p><pre><code class="hljs">http://images.google.com/images?num=30&amp;q=larry+bird</code></pre><p>你必须要把网址转成：</p><pre><code class="hljs">http://images.google.com/images?num=30&amp;amp;q=larry+bird</code></pre><p>才能放到链接标签的 href 属性里。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p><p>Markdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 &amp; 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 &amp;。所以你如果要在文件中插入一个著作权的符号，你可以这样写：</p><pre><code class="hljs">&amp;copy;</code></pre><p>Markdown 将不会对这段文字做修改，但是如果你这样写：</p><pre><code class="hljs">AT&amp;T</code></pre><p>Markdown 就会将它转为：</p><pre><code class="hljs">AT&amp;amp;T</code></pre><p>类似的状况也会发生在 &lt; 符号上，因为 Markdown 支持 行内 HTML ，如果你使用 &lt; 符号作为 HTML 标签的分隔符，那 Markdown 也不会对它做任何转换，但是如果你是写：</p><pre><code class="hljs">4 &lt; 5</code></pre><p>Markdown 将会把它转换为：</p><pre><code class="hljs">4 &amp;lt; 5</code></pre><p>需要特别注意的是，在 Markdown 的块级元素和内联元素中， &lt; 和 &amp; 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（在 HTML 语法中，你要手动把所有的 &lt; 和 &amp; 都转换为 HTML 实体。）</p><hr><h2 id="12-Markdown-内嵌-HTML-标签"><a href="#12-Markdown-内嵌-HTML-标签" class="headerlink" title="12. Markdown 内嵌 HTML 标签"></a>12. Markdown 内嵌 HTML 标签</h2><p>对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可。</p><h3 id="行级內联标签"><a href="#行级內联标签" class="headerlink" title="行级內联标签"></a>行级內联标签</h3><p>HTML 的行级內联标签如<code> &lt;span&gt;、&lt;cite&gt;、&lt;del&gt;</code> 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的 <code>&lt;a&gt; </code>或 <code>&lt;img&gt; </code>标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。</p><pre><code class="hljs">This **word** is bold. This &lt;em&gt;word&lt;/em&gt; is italic.</code></pre><p>渲染效果如下:</p><p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h3 id="区块标签"><a href="#区块标签" class="headerlink" title="区块标签"></a>区块标签</h3><p>区块元素──比如 <code>&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;</code> 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><p>例如，在 Markdown 文件里加上一段 HTML 表格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">This is a regular paragraph.<br><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br>This is another regular paragraph.<br></code></pre></td></tr></table></figure><p>请注意，Markdown 语法在 HTML 区块标签中将不会被进行处理。例如，你无法在 HTML 区块内使用 Markdown 形式的<code>*强调*</code>。</p><hr><h2 id="13-Markdown-表格"><a href="#13-Markdown-表格" class="headerlink" title="13. Markdown 表格"></a>13. Markdown 表格</h2><p>要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> ----------- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：<br>| Syntax      | Description |<br>| ———– | ———– |<br>| Header      | Title       |<br>| Paragraph   | Text        |</p><p>单元格宽度可以变化，如下所示。呈现的输出将看起来相同。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> --- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header </span>|<span class="hljs-string"> Title </span>|<br>|<span class="hljs-string"> Paragraph </span>|<span class="hljs-string"> Text </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table><p>Tip: 使用连字符和管道创建表可能很麻烦。为了加快该过程，请尝试使用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables Generator</a>。使用图形界面构建表，然后将生成的Markdown格式的文本复制到文件中。</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<span class="hljs-string"> Test Text     </span>|<br>|<span class="hljs-string"> :---        </span>|<span class="hljs-string">    :----:   </span>|<span class="hljs-string">          ---: </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<span class="hljs-string"> Here&#x27;s this   </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<span class="hljs-string"> And more      </span>|<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><table><thead><tr><th align="left">Syntax</th><th align="center">Description</th><th align="right">Test Text</th></tr></thead><tbody><tr><td align="left">Header</td><td align="center">Title</td><td align="right">Here’s this</td></tr><tr><td align="left">Paragraph</td><td align="center">Text</td><td align="right">And more</td></tr></tbody></table><h3 id="格式化表格中的文字"><a href="#格式化表格中的文字" class="headerlink" title="格式化表格中的文字"></a>格式化表格中的文字</h3><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（`）中的单词或短语，而不是代码块）和强调。</p><p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</p><h3 id="在表中转义管道字符"><a href="#在表中转义管道字符" class="headerlink" title="在表中转义管道字符"></a>在表中转义管道字符</h3><p>您可以使用表格的HTML字符代码（<code>&amp;#124;</code>）在表中显示竖线（|）字符。</p><hr><h3 id="无标题表格"><a href="#无标题表格" class="headerlink" title="无标题表格"></a>无标题表格</h3><p>采用HTML表格</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-weight:700&quot;</span>&gt;</span>最小地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>128.14.32.0<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>10000000 00001110 00100000 00000000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-weight:700&quot;</span>&gt;</span>最大地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>128.14.47.255<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>10000000 00001110 001011111 11111111<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table align="center">    <tr>        <td align="center" style="font-weight:700">最小地址</td>        <td align="center">128.14.32.0</td>        <td align="center">10000000 00001110 00100000 00000000</td>    </tr>    <tr>        <td align="center" style="font-weight:700">最大地址</td>        <td align="center">128.14.47.255</td>        <td align="center">10000000 00001110 001011111 11111111</td>    </tr></table><h2 id="14-MarkDown-删除线"><a href="#14-MarkDown-删除线" class="headerlink" title="14. MarkDown 删除线"></a>14. MarkDown 删除线</h2><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号~~。</p><pre><code class="hljs">~~世界是平坦的。~~ 我们现在知道世界是圆的。</code></pre><p><del>世界是平坦的。</del> 我们现在知道世界是圆的。</p><hr><h2 id="15-Markdown-任务列表语法"><a href="#15-Markdown-任务列表语法" class="headerlink" title="15. Markdown 任务列表语法"></a>15. Markdown 任务列表语法</h2><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[x] Write the press release<br><span class="hljs-bullet">- </span>[ ] Update the website<br><span class="hljs-bullet">- </span>[ ] Contact the media<br></code></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> Write the press release</li><li><input disabled="" type="checkbox"> Update the website</li><li><input disabled="" type="checkbox"> Contact the media</li></ul><hr><h2 id="16-Markdown-使用-Emoji-表情"><a href="#16-Markdown-使用-Emoji-表情" class="headerlink" title="16. Markdown 使用 Emoji 表情"></a>16. Markdown 使用 Emoji 表情</h2><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入emoji shortcodes。</p><h3 id="复制和粘贴表情符号"><a href="#复制和粘贴表情符号" class="headerlink" title="复制和粘贴表情符号"></a>复制和粘贴表情符号</h3><p>在大多数情况下，您可以简单地从<a href="https://emojipedia.org/">Emojipedia</a> 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。</p><p>Tip: 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。.</p><p>😃</p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档</tag>
      
      <tag>基础</tag>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 从0开始搭建博客</title>
    <link href="/2022/10/30/Hexo%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/10/30/Hexo%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-从0开始搭建博客"><a href="#Hexo-从0开始搭建博客" class="headerlink" title="Hexo 从0开始搭建博客"></a>Hexo 从0开始搭建博客</h1><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h3><p>直接到<a href="https://nodejs.org/en/download/">官网</a>上下载安装即可</p><ul><li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li>Node自带npm<h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3></li><li>Windows：下载并安装<a href="https://git-scm.com/download/win">git</a></li><li>Mac:使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code><br><img src="https://img-blog.csdnimg.cn/img_convert/343d28b9c9178b0b857abee140a668b1.png" alt="安装Node.js"></li></ul><h2 id="二、开始安装Hexo"><a href="#二、开始安装Hexo" class="headerlink" title="二、开始安装Hexo"></a>二、开始安装Hexo</h2><h3 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br>或者<br>cnpm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>安装完成可输入<code>hexo -v</code>查看版本<br><img src="https://img-blog.csdnimg.cn/img_convert/bba538484708b3e30f14af8557501c3c.png" alt="安装hexo"></p><h3 id="2-初始化hexo，新建存储博客的文件夹"><a href="#2-初始化hexo，新建存储博客的文件夹" class="headerlink" title="2.初始化hexo，新建存储博客的文件夹"></a>2.初始化hexo，新建存储博客的文件夹</h3><pre><code class="hljs">hexo init myblog</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/d01a6881209137448e5385dd3534097d.png" alt="初始化hexo"></p><h3 id="3-进入文件夹，安装一下npm"><a href="#3-进入文件夹，安装一下npm" class="headerlink" title="3.进入文件夹，安装一下npm"></a>3.进入文件夹，安装一下npm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> myblog<br>npm install<br></code></pre></td></tr></table></figure><p>可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了<br><img src="https://img-blog.csdnimg.cn/img_convert/bcf516435e0c18ccdd4bb12f2fe04e2a.png" alt="配置hexo"></p><h3 id="4、启动服务站点"><a href="#4、启动服务站点" class="headerlink" title="4、启动服务站点"></a>4、启动服务站点</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo g<br>hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/af32bf9e9c204c69d873df7c3437c3a4.png" alt="启动服务站点"></p><p>访问<a href="http://localhost:4000/">http://localhost:4000/</a> 至此hero就搭建好了。可以在本地访问了</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3a611caeb2993779a773aaad9864d493.png" alt="访问服务站点"></p><hr><h2 id="三、GitHub上建站访问"><a href="#三、GitHub上建站访问" class="headerlink" title="三、GitHub上建站访问"></a>三、GitHub上建站访问</h2><h3 id="1、新建guthub仓库"><a href="#1、新建guthub仓库" class="headerlink" title="1、新建guthub仓库"></a>1、新建guthub仓库</h3><p>仓库名称限制了为你的：用户名+.github.io</p><h3 id="2、安装hexo上传插件"><a href="#2、安装hexo上传插件" class="headerlink" title="2、安装hexo上传插件"></a>2、安装hexo上传插件</h3><pre><code class="hljs">npm install hexo-deployer-git --save</code></pre><h3 id="3、修改hexo配置文件指定仓库路径"><a href="#3、修改hexo配置文件指定仓库路径" class="headerlink" title="3、修改hexo配置文件指定仓库路径"></a>3、修改hexo配置文件指定仓库路径</h3><p>可在文件夹中直接打开文件，也可通过vim直接编辑</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">vim</span> _config.yml #找到<span class="hljs-type">Deploymentdeploy</span>:  <span class="hljs-keyword">type</span>: git  repo: 你的github仓库路径  branch: master<br></code></pre></td></tr></table></figure><h3 id="4、推送站点到github"><a href="#4、推送站点到github" class="headerlink" title="4、推送站点到github"></a>4、推送站点到github</h3><pre><code class="hljs">hexo d</code></pre><p>推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现：鉴权失败（用户名密码错误）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">解决方式就是获取<span class="hljs-function"><span class="hljs-title">token</span>，登录github设置setting-&gt;</span>D<span class="hljs-function"><span class="hljs-title">eveloper</span> Settings-&gt;</span>Prosonal access tokens 创建一个新token。然后就可以拿这个token当密码输入了。<br></code></pre></td></tr></table></figure><h3 id="5、尝试访问"><a href="#5、尝试访问" class="headerlink" title="5、尝试访问"></a>5、尝试访问</h3><p>输入你的仓库名称,即可访问成功。</p><p><a href="https://olivermao.github.io/">https://olivermao.github.io/</a></p><hr><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><p>在GitHub上搜索hexo主题，按照各自的主题文档上面一步步操作即可。</p><p>本站采用 <a href="https://hexo.fluid-dev.com/docs/"><strong>Fluid</strong></a></p><hr><h2 id="五、更新仓库"><a href="#五、更新仓库" class="headerlink" title="五、更新仓库"></a>五、更新仓库</h2><p>本地调试完之后。就可以更新到github上了</p><p>使用以下命令进行部署上传：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><hr><h2 id="六、撰写新文章"><a href="#六、撰写新文章" class="headerlink" title="六、撰写新文章"></a>六、撰写新文章</h2><h3 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h3><p>在站点文件夹打开git（或cmd）使用命令：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的第一篇博客&quot;</span><br></code></pre></td></tr></table></figure><p>编写完成后使用以下命令进行预览：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><h3 id="草稿箱"><a href="#草稿箱" class="headerlink" title="草稿箱"></a>草稿箱</h3><p>很多时候我们需要先写成草稿，而暂时不发布出去。draft page就可以满足我们的要求，我们的网站上是看不到草稿文件的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo new draft <span class="hljs-selector-tag">b</span><br>hexo server <span class="hljs-attr">--draft</span><br>hexo publish <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><hr><h2 id="七、新建页面"><a href="#七、新建页面" class="headerlink" title="七、新建页面"></a>七、新建页面</h2><p>有时我们不满足主题自由的一些页面，希望自己添加一些页面。</p><p>我们可以新建页面,新建页面则会在hexo的source中新建该页面文件并生成md文件，这就是你要编辑的博客页了。</p><pre><code class="hljs">hexo new page &quot;resouces&quot;</code></pre><p>然后打开主题的配置文件_config.yml，在菜单属性menu中的添加如下（注意不是Hexo的配置文件）</p><p>将页面路径联接到页面上去</p><pre><code class="hljs">菜单自定义名称：/生成的页面名称</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/9011b89391152bc01be752ec6fd97d87.png" alt="配置页面"></p><p>当我们点击资源时后会跳转到我们自定义的博客页了</p><blockquote><p>参考：[1] 清风.[EB/OL]. <a href="https://blog.csdn.net/weixin_45019350/article/details/121901433.-">https://blog.csdn.net/weixin_45019350/article/details/121901433.-</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>文档</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
